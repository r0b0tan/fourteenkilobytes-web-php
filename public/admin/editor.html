<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor - fourteenkilobytes</title>
  <link rel="stylesheet" href="/admin/style.css">
</head>
<body>
  <div class="header">
    <h1>Neuer Build</h1>
    <nav>
      <a href="index.html">‚Üê Zur√ºck</a>
      <a href="/" target="_blank">Blog</a>
    </nav>
  </div>

  <div id="message" class="message hidden"></div>

  <!-- Card: Head -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title">Head</h2>
    </div>
    <div class="card-body card-body-with-rail">
      <div class="card-content">
        <div class="base-data-row">
          <div class="form-group">
            <label for="title">Titel</label>
            <input type="text" id="title" placeholder="Mein erster Post">
          </div>
          <div class="form-group">
            <label for="slug">Slug</label>
            <input type="text" id="slug" placeholder="mein-erster-post">
          </div>
          <div class="form-group">
            <label for="page-type">Build-Typ</label>
            <select id="page-type" class="page-type-select">
              <option value="post">Blog-Post</option>
              <option value="page">Statische Seite</option>
            </select>
            <span id="page-type-hint" class="text-small text-muted"></span>
          </div>
        </div>

        <!-- Header-Override -->
        <div class="override-section override-section-spaced">
          <div class="override-section-header">
            <label class="override-toggle">
              <input type="checkbox" id="nav-enabled">
              <span>Navigation √ºberschreiben</span>
            </label>
            <p id="nav-global-hint" class="override-hint">‚úì Globale Navigation wird verwendet</p>
          </div>
          <div id="nav-editor" class="override-editor hidden">
            <div id="nav-links" class="nav-links"></div>
            <button type="button" id="add-nav-link" class="btn-small btn-secondary">+ Link</button>
          </div>
        </div>
      </div>
      <div class="card-rail">
        <div class="rail-item">
          <span>Title</span>
          <span id="title-bytes">0 B</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Card: Body -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title">Body</h2>
    </div>
    <div class="card-body card-body-with-rail">
      <div class="card-content">
        <div id="block-editor" class="block-editor"></div>
        <div class="block-actions-row">
          <button type="button" id="add-block-btn" class="btn-small btn-secondary">Block hinzuf√ºgen</button>
          <div id="add-block-dropdown" class="add-block-dropdown hidden">
            <button type="button" data-type="paragraph">Absatz</button>
            <button type="button" data-type="heading" data-level="1">√úberschrift 1</button>
            <button type="button" data-type="heading" data-level="2">√úberschrift 2</button>
            <button type="button" data-type="heading" data-level="3">√úberschrift 3</button>
            <button type="button" data-type="heading" data-level="4">√úberschrift 4</button>
            <button type="button" data-type="heading" data-level="5">√úberschrift 5</button>
            <button type="button" data-type="heading" data-level="6">√úberschrift 6</button>
            <button type="button" data-type="bloglist">Blogliste</button>
          </div>
        </div>
        <p id="content-error" class="text-small text-danger hidden"></p>
      </div>
      <div class="card-rail" id="content-rail">
        <!-- Block byte indicators werden hier per JS eingef√ºgt -->
        <div class="rail-total">
          <span>Content</span>
          <span id="cost-content-total">0 B</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Card: Footer -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title">Footer</h2>
    </div>
    <div class="card-body card-body-with-rail">
      <div class="card-content">
        <!-- Footer-Override -->
        <div class="override-section override-section-first">
          <div class="override-section-header">
            <label class="override-toggle">
              <input type="checkbox" id="footer-enabled">
              <span>Footer √ºberschreiben</span>
            </label>
            <p id="footer-global-hint" class="override-hint">‚úì Globaler Footer wird verwendet</p>
          </div>
          <div id="footer-editor" class="override-editor hidden">
            <input type="text" id="footer-text" placeholder="¬© 2024 Mein Blog">
          </div>
        </div>

        <!-- CSS Override -->
        <div class="override-section">
          <div class="override-section-header">
            <label class="override-toggle">
              <input type="checkbox" id="css-enabled">
              <span>CSS erg√§nzen</span>
            </label>
            <p id="css-global-hint" class="override-hint">‚úì Nur globales CSS wird verwendet</p>
          </div>
          <div id="css-editor" class="override-editor">
            <p class="css-warning-hint">Zus√§tzliches CSS wird nach globalem CSS eingef√ºgt und erh√∂ht die Seitengr√∂√üe.</p>
            <textarea id="css-rules" rows="10" placeholder="/* Zus√§tzliches CSS */"></textarea>
          </div>
        </div>
      </div>
      <div class="card-rail">
        <div class="rail-item">
          <span>CSS</span>
          <span id="css-bytes">0 B</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Link Edit Popup for Navigation -->
  <div id="nav-link-popup" class="nav-link-popup hidden">
    <div class="popup-content">
      <div class="form-group">
        <label>Text</label>
        <input type="text" id="nav-link-text" placeholder="Home">
      </div>
      <div class="form-group">
        <label>Ziel</label>
        <input type="text" id="nav-link-href" placeholder="/">
      </div>
      <div class="popup-actions">
        <button type="button" id="nav-link-save">OK</button>
        <button type="button" id="nav-link-delete" class="btn-danger btn-small">L√∂schen</button>
        <button type="button" id="nav-link-cancel" class="btn-secondary">Abbrechen</button>
      </div>
    </div>
  </div>

  <!-- Floating Format Toolbar (hidden by default) -->
  <div id="format-toolbar" class="format-toolbar hidden">
    <button type="button" data-cmd="bold" title="Fett"><b>B</b></button>
    <button type="button" data-cmd="italic" title="Kursiv"><i>I</i></button>
    <button type="button" data-cmd="link" title="Link">üîó</button>
  </div>

  <!-- Link Popup for content -->
  <div id="link-popup" class="link-popup hidden">
    <input type="text" id="link-href" placeholder="/pfad oder #anker">
    <button type="button" id="link-apply">OK</button>
    <button type="button" id="link-cancel" class="btn-secondary btn-small">√ó</button>
  </div>

  <!-- Build Summary -->
  <div class="build-summary">
    <div class="build-summary-content">
      <details class="build-breakdown" open>
        <summary>Build-Aufschl√ºsselung</summary>
        <div class="breakdown-table">
          <div class="breakdown-row">
            <span>Fixkosten (Basis)</span>
            <span id="breakdown-base">0 B</span>
          </div>
          <div class="breakdown-row" id="breakdown-nav-row" style="display: none;">
            <span>Navigation</span>
            <span id="breakdown-nav">0 B</span>
          </div>
          <div class="breakdown-row" id="breakdown-footer-row" style="display: none;">
            <span>Footer</span>
            <span id="breakdown-footer">0 B</span>
          </div>
          <div class="breakdown-row" id="breakdown-css-row" style="display: none;">
            <span>CSS</span>
            <span id="breakdown-css">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Content gesamt</span>
            <span id="breakdown-content">0 B</span>
          </div>
          <div class="breakdown-row breakdown-row-total">
            <span>Gesamt</span>
            <span id="breakdown-total">0 B / 14.336 B</span>
          </div>
        </div>
      </details>
      <div class="byte-bar">
        <div id="byte-fill-overhead" class="byte-fill-overhead" style="width: 0%"></div>
        <div id="byte-fill-content" class="byte-fill-content" style="width: 0%"></div>
      </div>
      <label id="pagination-option" class="pagination-checkbox hidden">
        <input type="checkbox" id="allow-pagination">
        <span>Automatisch auf mehrere Seiten aufteilen</span>
      </label>
    </div>
    <button id="publish-btn" class="btn-primary">Build & Publish</button>
  </div>

  <!-- Live CSS Container -->
  <style id="live-css"></style>

  <script type="module" src="app.js"></script>
  <script type="module">
    (async function() {
      // Check if setup is complete
      const status = await App.getSetupStatus();
      if (!status.setupComplete) {
        window.location.href = '/admin/setup';
        return;
      }

      // Check auth
      const config = await App.getConfig();
      if (config.authEnabled && !(await App.isLoggedIn())) {
        window.location.href = 'index.html';
        return;
      }

      // Load settings with global header/footer/CSS
      const settings = await App.getSettings();
      window.globalConfig = settings;

      // Elements
      const pageTypeSelect = document.getElementById('page-type');
      const pageTypeHint = document.getElementById('page-type-hint');
      const titleInput = document.getElementById('title');
      const slugInput = document.getElementById('slug');
      const blockEditor = document.getElementById('block-editor');
      const addBlockBtn = document.getElementById('add-block-btn');
      const addBlockDropdown = document.getElementById('add-block-dropdown');
      const formatToolbar = document.getElementById('format-toolbar');
      const linkPopup = document.getElementById('link-popup');
      const linkHrefInput = document.getElementById('link-href');
      const linkApplyBtn = document.getElementById('link-apply');
      const linkCancelBtn = document.getElementById('link-cancel');
      const navEnabled = document.getElementById('nav-enabled');
      const navEditor = document.getElementById('nav-editor');
      const navGlobalHint = document.getElementById('nav-global-hint');
      const navLinks = document.getElementById('nav-links');
      const addNavLinkBtn = document.getElementById('add-nav-link');
      const navLinkPopup = document.getElementById('nav-link-popup');
      const navLinkText = document.getElementById('nav-link-text');
      const navLinkHref = document.getElementById('nav-link-href');
      const navLinkSave = document.getElementById('nav-link-save');
      const navLinkDelete = document.getElementById('nav-link-delete');
      const navLinkCancel = document.getElementById('nav-link-cancel');
      const footerEnabled = document.getElementById('footer-enabled');
      const footerEditor = document.getElementById('footer-editor');
      const footerGlobalHint = document.getElementById('footer-global-hint');
      const footerText = document.getElementById('footer-text');
      const cssEnabled = document.getElementById('css-enabled');
      const cssEditor = document.getElementById('css-editor');
      const cssGlobalHint = document.getElementById('css-global-hint');
      const cssRules = document.getElementById('css-rules');
      const liveCSS = document.getElementById('live-css');
      const publishBtn = document.getElementById('publish-btn');
      const paginationOption = document.getElementById('pagination-option');
      const allowPaginationCheckbox = document.getElementById('allow-pagination');
      const messageEl = document.getElementById('message');

      // Byte display elements
      const costContentTotal = document.getElementById('cost-content-total');
      const contentRail = document.getElementById('content-rail');
      const titleBytesEl = document.getElementById('title-bytes');
      const cssBytesEl = document.getElementById('css-bytes');

      // Build Summary elements
      const breakdownBase = document.getElementById('breakdown-base');
      const breakdownNav = document.getElementById('breakdown-nav');
      const breakdownNavRow = document.getElementById('breakdown-nav-row');
      const breakdownFooter = document.getElementById('breakdown-footer');
      const breakdownFooterRow = document.getElementById('breakdown-footer-row');
      const breakdownCss = document.getElementById('breakdown-css');
      const breakdownCssRow = document.getElementById('breakdown-css-row');
      const breakdownContent = document.getElementById('breakdown-content');
      const breakdownTotal = document.getElementById('breakdown-total');
      const byteFillOverhead = document.getElementById('byte-fill-overhead');
      const byteFillContent = document.getElementById('byte-fill-content');

      // State
      let savedSelection = null;
      let editingNavLink = null; // The chip element being edited

      // ============ PAGE TYPE ============

      pageTypeSelect.addEventListener('change', () => {
        const type = pageTypeSelect.value;
        if (type === 'page') {
          pageTypeHint.textContent = '(nicht im Feed)';
        } else {
          pageTypeHint.textContent = '';
        }
      });

      // ============ NAVIGATION EDITOR ============

      // Load global navigation into disabled fields
      function loadGlobalNavigation() {
        navLinks.innerHTML = '';
        if (window.globalConfig?.header?.links) {
          window.globalConfig.header.links.forEach(link => {
            navLinks.appendChild(createNavChip(link.text, link.href));
          });
        }
      }

      navEnabled.addEventListener('change', () => {
        navGlobalHint.classList.toggle('hidden', navEnabled.checked);
        
        // Toggle disabled state
        const chips = navLinks.querySelectorAll('.nav-chip');
        chips.forEach(chip => {
          chip.style.pointerEvents = navEnabled.checked ? 'auto' : 'none';
          chip.style.opacity = navEnabled.checked ? '1' : '0.6';
        });
        addNavLinkBtn.disabled = !navEnabled.checked;
      });

      function createNavChip(text, href) {
        const chip = document.createElement('span');
        chip.className = 'nav-chip';
        chip.dataset.href = href;
        chip.textContent = text;
        chip.addEventListener('click', () => editNavLink(chip));
        return chip;
      }

      function editNavLink(chip) {
        editingNavLink = chip;
        navLinkText.value = chip.textContent;
        navLinkHref.value = chip.dataset.href;
        navLinkDelete.classList.remove('hidden');
        navLinkPopup.classList.remove('hidden');
        navLinkText.focus();
      }

      addNavLinkBtn.addEventListener('click', () => {
        editingNavLink = null;
        navLinkText.value = '';
        navLinkHref.value = '';
        navLinkDelete.classList.add('hidden');
        navLinkPopup.classList.remove('hidden');
        navLinkText.focus();
      });

      navLinkSave.addEventListener('click', () => {
        const text = navLinkText.value.trim();
        const href = navLinkHref.value.trim();
        if (!text || !href) return;

        if (editingNavLink) {
          editingNavLink.textContent = text;
          editingNavLink.dataset.href = href;
        } else {
          navLinks.appendChild(createNavChip(text, href));
        }
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      navLinkDelete.addEventListener('click', () => {
        if (editingNavLink) {
          editingNavLink.remove();
        }
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      navLinkCancel.addEventListener('click', () => {
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      // ============ FOOTER EDITOR ============

      // Load global footer into disabled field
      function loadGlobalFooter() {
        if (window.globalConfig?.footer?.content) {
          footerText.value = window.globalConfig.footer.content;
        }
      }

      footerEnabled.addEventListener('change', () => {
        footerGlobalHint.classList.toggle('hidden', footerEnabled.checked);
        footerText.disabled = !footerEnabled.checked;
      });

      // ============ CSS EDITOR ============

      // Load global CSS into disabled field
      function loadGlobalCSS() {
        if (window.globalConfig?.globalCss) {
          cssRules.value = window.globalConfig.globalCss;
        }
      }

      cssEnabled.addEventListener('change', () => {
        cssGlobalHint.classList.toggle('hidden', cssEnabled.checked);
        cssRules.disabled = !cssEnabled.checked;
      });

      // ============ LIVE CSS ============

      cssRules.addEventListener('input', () => {
        applyLiveCSS();
      });

      function applyLiveCSS() {
        const css = cssRules.value.trim();
        // Scope CSS to block-editor to avoid breaking admin UI
        // Simple approach: prefix all rules with .block-editor
        if (!css) {
          liveCSS.textContent = '';
          return;
        }

        // Basic scoping - wrap in .block-editor context
        // This won't handle all edge cases but works for simple rules
        try {
          const scopedCSS = css.replace(/([^{}]+)\{/g, (match, selector) => {
            const selectors = selector.split(',').map(s => {
              s = s.trim();
              if (s.startsWith('@') || s.startsWith('from') || s.startsWith('to') || /^\d+%$/.test(s)) {
                return s;
              }
              if (s === 'body' || s === 'html') {
                return '.block-editor';
              }
              return `.block-editor ${s}`;
            }).join(', ');
            return selectors + ' {';
          });
          liveCSS.textContent = scopedCSS;
        } catch (e) {
          // Invalid CSS, ignore
        }
      }

      // ============ AUTO-SLUG ============

      titleInput.addEventListener('input', () => {
        if (!slugInput.dataset.manual) {
          slugInput.value = App.slugify(titleInput.value);
        }
        updateTitleBytes();
      });

      slugInput.addEventListener('input', () => {
        slugInput.dataset.manual = 'true';
      });

      // ============ BLOCK EDITOR ============

      function createBlockElement(type, level, initialHtml = '') {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.dataset.type = type;
        if (level) block.dataset.level = level;

        // Block header with type selector and actions
        const header = document.createElement('div');
        header.className = 'block-header';

        // Type selector (nur wenn nicht bloglist)
        if (type !== 'bloglist') {
          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="paragraph">Absatz</option>
            <option value="heading-1">H1</option>
            <option value="heading-2">H2</option>
            <option value="heading-3">H3</option>
            <option value="heading-4">H4</option>
            <option value="heading-5">H5</option>
            <option value="heading-6">H6</option>
          `;
          typeSelect.value = type === 'heading' ? `heading-${level}` : 'paragraph';
          typeSelect.addEventListener('change', () => {
            const val = typeSelect.value;
            if (val === 'paragraph') {
              block.dataset.type = 'paragraph';
              delete block.dataset.level;
            } else {
              block.dataset.type = 'heading';
              block.dataset.level = val.split('-')[1];
            }
            updateBlockStyling(block);
          });
          header.appendChild(typeSelect);
        } else {
          const label = document.createElement('span');
          label.className = 'block-type-label';
          label.textContent = 'Blogliste';
          header.appendChild(label);
        }

        const actions = document.createElement('div');
        actions.className = 'block-item-actions';

        const upBtn = document.createElement('button');
        upBtn.type = 'button';
        upBtn.textContent = '‚Üë';
        upBtn.title = 'Nach oben';
        upBtn.addEventListener('click', () => moveBlock(block, -1));
        actions.appendChild(upBtn);

        const downBtn = document.createElement('button');
        downBtn.type = 'button';
        downBtn.textContent = '‚Üì';
        downBtn.title = 'Nach unten';
        downBtn.addEventListener('click', () => moveBlock(block, 1));
        actions.appendChild(downBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.textContent = '√ó';
        deleteBtn.title = 'L√∂schen';
        deleteBtn.addEventListener('click', () => block.remove());
        actions.appendChild(deleteBtn);

        header.appendChild(actions);
        
        // Byte indicator f√ºr diesen Block
        const byteIndicator = document.createElement('div');
        byteIndicator.className = 'block-byte-indicator';
        byteIndicator.textContent = '0 B';
        block.appendChild(byteIndicator);
        
        block.appendChild(header);

        // Content area
        const content = document.createElement('div');
        content.className = 'block-content';
        if (type === 'bloglist') {
          content.contentEditable = 'false';
          content.className = 'block-content block-bloglist';
          content.innerHTML = '<em style="color: #999;">Hier werden automatisch alle Blog-Posts aufgelistet</em>';
        } else {
          content.contentEditable = 'true';
          content.dataset.placeholder = type === 'heading' ? '√úberschrift...' : 'Text eingeben...';
          content.innerHTML = initialHtml;
        }
        block.appendChild(content);

        updateBlockStyling(block);
        return block;
      }

      function updateBlockStyling(block) {
        const content = block.querySelector('.block-content');
        const type = block.dataset.type;
        const level = block.dataset.level;

        // Reset styles
        content.style.fontSize = '';
        content.style.fontWeight = '';

        if (type === 'heading') {
          content.style.fontWeight = 'bold';
          const sizes = { 1: '2rem', 2: '1.5rem', 3: '1.25rem', 4: '1.1rem', 5: '1rem', 6: '0.875rem' };
          content.style.fontSize = sizes[level] || '1rem';
          content.dataset.placeholder = '√úberschrift...';
        } else {
          content.dataset.placeholder = 'Text eingeben...';
        }
      }

      function moveBlock(block, direction) {
        const blocks = Array.from(blockEditor.children);
        const index = blocks.indexOf(block);
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= blocks.length) return;

        if (direction < 0) {
          blockEditor.insertBefore(block, blocks[newIndex]);
        } else {
          blockEditor.insertBefore(block, blocks[newIndex].nextSibling);
        }
      }

      // ============ FLOATING FORMAT TOOLBAR ============

      document.addEventListener('selectionchange', () => {
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) {
          formatToolbar.classList.add('hidden');
          return;
        }

        // Check if selection is within block editor
        const range = sel.getRangeAt(0);
        const container = range.commonAncestorContainer;
        const blockContent = container.nodeType === Node.TEXT_NODE
          ? container.parentElement.closest('.block-content')
          : container.closest('.block-content');

        if (!blockContent || !blockEditor.contains(blockContent)) {
          formatToolbar.classList.add('hidden');
          return;
        }

        // Position toolbar above selection
        const rect = range.getBoundingClientRect();
        formatToolbar.style.top = (rect.top + window.scrollY - 40) + 'px';
        formatToolbar.style.left = (rect.left + window.scrollX + rect.width / 2 - 50) + 'px';
        formatToolbar.classList.remove('hidden');
      });

      formatToolbar.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const cmd = btn.dataset.cmd;
        if (cmd === 'bold') {
          document.execCommand('bold', false, null);
        } else if (cmd === 'italic') {
          document.execCommand('italic', false, null);
        } else if (cmd === 'link') {
          showLinkPopup();
        }
      });

      // ============ LINK POPUP ============

      function showLinkPopup() {
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) return;

        savedSelection = sel.getRangeAt(0).cloneRange();

        const parentLink = sel.anchorNode.parentElement.closest('a');
        linkHrefInput.value = parentLink ? parentLink.getAttribute('href') : '';

        const rect = savedSelection.getBoundingClientRect();
        linkPopup.style.top = (rect.bottom + window.scrollY + 5) + 'px';
        linkPopup.style.left = (rect.left + window.scrollX) + 'px';
        linkPopup.classList.remove('hidden');
        linkHrefInput.focus();
      }

      linkApplyBtn.addEventListener('click', () => {
        const href = linkHrefInput.value.trim();
        if (!href) {
          linkPopup.classList.add('hidden');
          return;
        }

        if (savedSelection) {
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(savedSelection);
          document.execCommand('createLink', false, href);
        }
        linkPopup.classList.add('hidden');
        savedSelection = null;
      });

      linkCancelBtn.addEventListener('click', () => {
        linkPopup.classList.add('hidden');
        savedSelection = null;
      });

      // ============ ADD BLOCK ============

      addBlockBtn.addEventListener('click', () => {
        addBlockDropdown.classList.toggle('hidden');
      });

      addBlockDropdown.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const type = btn.dataset.type;
        const level = btn.dataset.level;
        const block = createBlockElement(type, level);
        blockEditor.appendChild(block);
        block.querySelector('.block-content').focus();
        addBlockDropdown.classList.add('hidden');
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.block-actions-row')) {
          addBlockDropdown.classList.add('hidden');
        }
        if (!e.target.closest('.nav-link-popup') && !e.target.closest('#add-nav-link') && !e.target.closest('.nav-chip')) {
          navLinkPopup.classList.add('hidden');
        }
      });

      // ============ BUILD INPUT ============

      function parseInlineNodes(element) {
        const nodes = [];

        function processNodeInto(node, targetArray) {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            if (text) {
              targetArray.push({ type: 'text', text });
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            const children = [];
            for (const child of node.childNodes) {
              processNodeInto(child, children);
            }

            if (tag === 'br') {
              targetArray.push({ type: 'linebreak' });
            } else if (tag === 'b' || tag === 'strong') {
              targetArray.push({ type: 'bold', children });
            } else if (tag === 'i' || tag === 'em') {
              targetArray.push({ type: 'italic', children });
            } else if (tag === 'a') {
              const href = node.getAttribute('href') || '';
              targetArray.push({ type: 'link', href, children });
            } else {
              targetArray.push(...children);
            }
          }
        }

        for (const child of element.childNodes) {
          processNodeInto(child, nodes);
        }

        if (nodes.length === 0) {
          nodes.push({ type: 'text', text: '' });
        }

        return nodes;
      }

      function getContentFromBlocks() {
        const blocks = blockEditor.querySelectorAll('.block-item');
        const content = [];

        for (const block of blocks) {
          const type = block.dataset.type;

          if (type === 'bloglist') {
            content.push({
              type: 'bloglist'
            });
          } else {
            const contentEl = block.querySelector('.block-content');
            const children = parseInlineNodes(contentEl);

            if (type === 'heading') {
              content.push({
                type: 'heading',
                level: parseInt(block.dataset.level, 10),
                children
              });
            } else {
              content.push({
                type: 'paragraph',
                children
              });
            }
          }
        }

        return content;
      }

      function getNavigationItems() {
        const chips = navLinks.querySelectorAll('.nav-chip');
        return Array.from(chips).map(chip => ({
          text: chip.textContent,
          href: chip.dataset.href
        }));
      }

      const contentError = document.getElementById('content-error');

      async function buildInput() {
        const content = getContentFromBlocks();
        
        // For preview with empty content, use minimal placeholder
        const finalContent = content.length > 0 
          ? content 
          : [{ type: 'paragraph', children: [{ type: 'text', text: '' }] }];
        contentError.classList.add('hidden');

        // Load posts if bloglist block is present
        let posts = [];
        const hasBloglist = finalContent.some(block => block.type === 'bloglist');
        if (hasBloglist) {
          try {
            posts = await App.getPosts();
            console.log('Loaded posts for bloglist:', posts);
          } catch (err) {
            console.warn('Failed to load posts for bloglist:', err);
          }
        }

        let navigation = null;
        if (navEnabled.checked) {
          const items = getNavigationItems();
          if (items.length > 0) {
            navigation = { items };
          }
        }

        let footer = null;
        if (footerEnabled.checked && footerText.value.trim()) {
          footer = { content: footerText.value.trim() };
        }

        let css = null;
        if (cssEnabled.checked && cssRules.value.trim()) {
          css = { rules: cssRules.value.trim() };
        }

        return {
          slug: slugInput.value.trim() || 'untitled',
          title: titleInput.value.trim() || 'Untitled',
          content: finalContent,
          navigation,
          footer,
          css,
          icons: [],
          posts,
          allowPagination: allowPaginationCheckbox.checked,
          buildId: crypto.randomUUID(),
          pageType: pageTypeSelect.value,
        };
      }

      // ============ BYTE COUNTER & COST RAIL ============

      function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        if (bytes < 1000) return bytes + ' B';
        return (bytes / 1024).toFixed(1) + ' KB';
      }

      function updateByteCounter(totalBytes, overheadBytes = 0, contentBytes = null, breakdown = null) {
        const limit = 14336;
        const actualContentBytes = contentBytes !== null ? contentBytes : Math.max(0, totalBytes - overheadBytes);
        const overheadPercent = Math.min((overheadBytes / limit) * 100, 100);
        const totalPercent = Math.min((totalBytes / limit) * 100, 100);

        // Update Build Summary breakdown
        if (breakdown) {
          breakdownBase.textContent = formatBytes(breakdown.base);
          breakdownNav.textContent = formatBytes(breakdown.navigation);
          breakdownFooter.textContent = formatBytes(breakdown.footer);
          breakdownCss.textContent = formatBytes(breakdown.css);
          breakdownContent.textContent = formatBytes(breakdown.content);
          breakdownTotal.textContent = `${formatBytes(totalBytes)} / 14.336 B`;

          // Update CSS rail indicator
          cssBytesEl.textContent = formatBytes(breakdown.css);

          // Show/hide rows based on values
          breakdownNavRow.style.display = breakdown.navigation > 0 ? 'flex' : 'none';
          breakdownFooterRow.style.display = breakdown.footer > 0 ? 'flex' : 'none';
          breakdownCssRow.style.display = breakdown.css > 0 ? 'flex' : 'none';
        }

        // Update Cost Rail content total
        costContentTotal.textContent = formatBytes(actualContentBytes);

        // Overhead bar (gray)
        byteFillOverhead.style.width = `${overheadPercent}%`;

        // Content bar (colored, starts after overhead)
        byteFillContent.style.left = `${overheadPercent}%`;
        byteFillContent.style.width = `${totalPercent - overheadPercent}%`;

        byteFillContent.classList.remove('warning', 'danger');
        if (totalPercent >= 100) {
          byteFillContent.classList.add('danger');
          paginationOption.classList.remove('hidden');
        } else if (totalPercent >= 80) {
          byteFillContent.classList.add('warning');
          paginationOption.classList.add('hidden');
        } else {
          paginationOption.classList.add('hidden');
        }
      }

      function updateCostRail() {
        const blocks = blockEditor.querySelectorAll('.block-item');
        let totalContentBytes = 0;

        // Clear existing rail items (except the total)
        contentRail.querySelectorAll('.rail-item').forEach(el => el.remove());

        const railTotal = contentRail.querySelector('.rail-total');

        blocks.forEach((block, index) => {
          const content = block.querySelector('.block-content');
          const type = block.dataset.type;
          const level = block.dataset.level;
          const text = content ? content.textContent.trim() : '';

          // Rough byte estimation (real calculation happens server-side)
          const bytes = new TextEncoder().encode(text).length + 50; // +50 for markup
          totalContentBytes += bytes;

          // Determine semantic label
          let label = 'Absatz';
          if (type === 'heading') {
            label = `H${level}`;
          } else if (type === 'bloglist') {
            label = 'Liste';
          }

          // Create rail item
          const railItem = document.createElement('div');
          railItem.className = 'rail-item';
          railItem.innerHTML = `<span>${label}</span><span>${formatBytes(bytes)}</span>`;
          contentRail.insertBefore(railItem, railTotal);
        });

        // Update content total
        costContentTotal.textContent = formatBytes(totalContentBytes);
      }

      function updateTitleBytes() {
        const title = titleInput.value.trim() || 'Untitled';
        // <title>TITEL</title> = 15 bytes markup + title bytes
        const titleBytes = new TextEncoder().encode(title).length + 15;
        titleBytesEl.textContent = formatBytes(titleBytes);
      }

      // ============ MESSAGES ============

      function showMessage(text, type = 'error') {
        messageEl.textContent = text;
        messageEl.className = `message ${type}`;
        messageEl.classList.remove('hidden');
      }

      function hideMessage() {
        messageEl.classList.add('hidden');
      }

      // ============ PUBLISH ============

      publishBtn.addEventListener('click', async () => {
        if (!confirm('Build ausf√ºhren und ver√∂ffentlichen?')) return;

        // Validate content before publish
        const blocks = blockEditor.querySelectorAll('.block-item');
        if (blocks.length === 0) {
          contentError.textContent = 'Mindestens ein Block erforderlich';
          contentError.classList.remove('hidden');
          showMessage('Mindestens ein Block erforderlich', 'error');
          return;
        }
        contentError.classList.add('hidden');

        publishBtn.disabled = true;
        hideMessage();

        try {
          const input = await buildInput();
          const result = await App.publish(input);

          if (result.pageCount && result.pageCount > 1) {
            showMessage(`Build abgeschlossen: /${result.slug} (${result.pageCount} Seiten, ${result.totalBytes} Bytes)`, 'success');
            updateByteCounter(result.totalBytes);
          } else {
            showMessage(`Build abgeschlossen: /${result.slug} (${result.bytes} Bytes)`, 'success');
            updateByteCounter(result.bytes);
          }

          // Disable editing after publish
          titleInput.disabled = true;
          slugInput.disabled = true;
          blockEditor.querySelectorAll('.block-content').forEach(el => {
            el.contentEditable = 'false';
          });
          blockEditor.querySelectorAll('button, select').forEach(el => {
            el.disabled = true;
          });
          addBlockBtn.disabled = true;
          navEnabled.disabled = true;
          footerEnabled.disabled = true;
          cssRules.disabled = true;
          publishBtn.disabled = true;
          publishBtn.textContent = 'Build abgeschlossen';
        } catch (err) {
          showMessage(err.message, 'error');
          console.error(err);
          publishBtn.disabled = false;
        }
      });

      // ============ INIT ============

      // Load global values into fields
      loadGlobalNavigation();
      loadGlobalFooter();
      loadGlobalCSS();
      
      // Set initial disabled states (after loading global values)
      navEditor.classList.remove('hidden');
      addNavLinkBtn.disabled = true;
      
      // Apply disabled state to navigation chips
      const initialChips = navLinks.querySelectorAll('.nav-chip');
      initialChips.forEach(chip => {
        chip.style.pointerEvents = 'none';
        chip.style.opacity = '0.6';
      });
      
      footerEditor.classList.remove('hidden');
      footerText.disabled = true;
      
      cssEditor.classList.remove('hidden');
      cssRules.disabled = true;

      function debounce(fn, delay) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      }

      updateByteCounter(0, 0);
      updateCostRail();
      updateTitleBytes();

      // Auto-update byte counter on content changes
      const debouncedPreview = debounce(async () => {
        try {
          const input = await buildInput();
          const result = await App.preview(input);
          updateByteCounter(result.bytes, result.overheadBytes || 0, result.contentBytes, result.breakdown);

          // Clear previous block warnings
          blockEditor.querySelectorAll('.block-item.block-too-large').forEach(el => {
            el.classList.remove('block-too-large');
          });
          contentError.classList.add('hidden');

          // Check if a block is too large for pagination
          if (result.blockTooLarge) {
            const blocks = blockEditor.querySelectorAll('.block-item');
            const blockIndex = result.blockTooLarge.blockIndex;
            if (blocks[blockIndex]) {
              blocks[blockIndex].classList.add('block-too-large');
              const kb = (result.blockTooLarge.blockSize / 1024).toFixed(1);
              contentError.textContent = `Block ${blockIndex + 1} ist zu gro√ü (${kb} KB). Bitte in mehrere Abs√§tze aufteilen.`;
              contentError.classList.remove('hidden');
            }
          }
        } catch (e) {
          // Ignore preview errors during editing
        }
      }, 500);

      // Listen for content changes
      blockEditor.addEventListener('input', () => {
        debouncedPreview();
        updateCostRail();
      });
      titleInput.addEventListener('input', debouncedPreview);
      footerText.addEventListener('input', debouncedPreview);
      cssRules.addEventListener('input', debouncedPreview);
      navEnabled.addEventListener('change', debouncedPreview);
      footerEnabled.addEventListener('change', debouncedPreview);
      cssEnabled.addEventListener('change', debouncedPreview);

      // Update cost rail when blocks change
      const observer = new MutationObserver(() => {
        updateCostRail();
      });
      observer.observe(blockEditor, { childList: true });

      // Initial preview to get overhead
      debouncedPreview();

    })();
  </script>
</body>
</html>
