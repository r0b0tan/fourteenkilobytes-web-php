<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor - fourteenkilobytes</title>
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="stylesheet" href="style.css">
  <script src="/admin/i18n.js"></script>
</head>

<body>
  <!-- Loading Overlay (shown until editor is loaded) -->
  <div id="loading-overlay" class="loading-overlay instant">
    <div class="loading-state">
      <div class="loading-spinner"></div>
      <span>Loading...</span>
    </div>
  </div>

  <!-- Use semantic header element for better document structure -->
  <header class="header">
    <div class="header-top">
      <!-- Logo with improved accessibility -->
      <div class="logo-container">
        <a href="index.html" class="logo" aria-label="14KB Dashboard">
          <!-- SVG uses currentColor to inherit accent from CSS -->
          <svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="32" height="32"
            viewBox="0 0 191.000000 191.000000" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
            <g transform="translate(0.000000,191.000000) scale(0.100000,-0.100000)" fill="currentColor" stroke="none">
              <path d="M406 1889 c-175 -35 -325 -178 -371 -356 -21 -81 -22 -1071 -1 -1149
47 -176 194 -315 374 -353 61 -13 1058 -16 1066 -3 2 4 -22 29 -55 55 -67 54
-152 157 -220 265 -24 39 -46 71 -49 72 -3 0 -18 -21 -34 -46 -41 -65 -64 -78
-116 -64 -63 17 -74 3 -65 -82 5 -57 4 -69 -10 -74 -24 -10 -45 15 -45 54 0
34 -1 34 -19 18 -10 -9 -21 -31 -25 -47 -5 -26 -10 -30 -33 -27 -23 2 -29 8
-31 35 -3 27 1 35 22 44 26 12 40 35 30 50 -9 16 -22 10 -58 -27 -40 -41 -72
-40 -82 2 -8 31 5 46 54 59 49 14 52 37 7 54 -19 7 -40 9 -45 6 -29 -18 -54
47 -28 73 17 17 35 15 66 -8 15 -12 41 -22 57 -23 28 -2 30 0 27 28 -8 85 -7
89 12 93 24 5 46 -23 46 -58 0 -37 29 -60 75 -60 51 0 69 18 101 106 l27 74
-19 42 c-26 59 -98 111 -196 143 -68 23 -91 36 -129 75 -58 59 -82 121 -109
278 -33 194 -24 242 44 242 36 0 242 -68 310 -102 87 -43 125 -102 140 -218 9
-60 39 -108 79 -125 20 -8 76 -15 138 -16 57 -1 142 -8 188 -15 46 -8 87 -12
90 -9 9 10 1 84 -14 119 -8 20 -25 41 -37 47 -20 11 -25 8 -55 -27 -27 -33
-35 -37 -50 -28 -10 6 -19 22 -21 36 -2 20 5 30 33 47 45 26 37 45 -16 38 -44
-6 -75 18 -65 51 9 29 30 33 70 17 57 -24 63 -18 22 24 -40 41 -44 66 -13 85
24 15 49 -2 59 -41 4 -17 15 -36 23 -43 21 -18 31 12 17 56 -8 27 -7 37 5 49
36 37 68 5 59 -58 -5 -32 -3 -47 8 -56 11 -9 18 -6 35 16 40 54 41 54 62 42
28 -15 22 -60 -11 -76 -57 -28 -65 -87 -25 -201 28 -82 31 -131 10 -171 -16
-31 -33 -41 -71 -41 -14 0 -34 -5 -45 -11 -26 -13 -15 -27 61 -79 30 -21 91
-70 135 -109 44 -39 85 -71 92 -71 20 0 18 909 -2 1003 -15 73 -58 162 -106
221 -40 48 -135 112 -207 139 -55 21 -71 22 -587 23 -305 1 -551 -2 -579 -7z" />
            </g>
          </svg>
          <!-- Stacked wordmark for compact branding -->
          <span class="logo-text" aria-hidden="true">14<br>KB</span>
        </a>
      </div>
      <!-- Semantic nav with improved structure -->
      <nav class="header-nav" aria-label="Main navigation">
        <a href="index.html" class="nav-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
            <polyline points="9 22 9 12 15 12 15 22" />
          </svg>
          <span data-i18n="nav.overview">Overview</span>
        </a>
        <a href="editor.html" class="nav-icon active" aria-current="page">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <line x1="12" y1="5" x2="12" y2="19" />
            <line x1="5" y1="12" x2="19" y2="12" />
          </svg>
          <span data-i18n="nav.new">New</span>
        </a>
        <a href="settings.html" class="nav-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
          </svg>
          <span data-i18n="nav.settings">Settings</span>
        </a>
        <a href="/" target="_blank" rel="noopener" class="nav-icon external-link">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
            <polyline points="15 3 21 3 21 9" />
            <line x1="10" y1="14" x2="21" y2="3" />
          </svg>
          <span data-i18n="nav.blog">Blog</span>
        </a>
        <!-- Visual separator before logout -->
        <span class="nav-separator" aria-hidden="true"></span>
        <a href="#" id="logout-btn" class="nav-icon logout-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
            <polyline points="16 17 21 12 16 7" />
            <line x1="21" y1="12" x2="9" y2="12" />
          </svg>
          <span data-i18n="nav.logout">Logout</span>
        </a>
      </nav>
    </div>
    <div style="margin-top: 32px;">
      <div>
        <h1 id="page-title" class="page-title" style="margin: 0;" data-i18n="editor.new">New</h1>
        <p id="page-subtitle" class="page-subtitle" style="margin: 4px 0 0 0;">Creating source Â· not yet compiled</p>
      </div>
      <div style="display: flex; gap: 12px; align-items: center; justify-content: flex-end; margin-top: 16px;">
        <div id="template-selector-container" style="display: flex; gap: 12px; align-items: center;">
          <select id="template-selector" class="page-type-select">
            <option value="" data-i18n="editor.templatesSelect">Select template...</option>
          </select>
          <span style="color: var(--border-primary);">|</span>
        </div>
        <button type="button" id="clear-all-btn" class="btn btn-secondary"> <svg width="14" height="14" viewBox="0 0 24 24"
            fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="23 4 23 10 17 10"></polyline>
            <polyline points="1 20 1 14 7 14"></polyline>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
          </svg><span data-i18n="editor.resetBtn">Reset</span></button>
      </div>
    </div>
  </header>

  <!-- Card: Head -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title" data-i18n="editor.head">Head</h2>
    </div>
    <div class="card-body card-body-grid">
      <div class="base-data-row">
        <div class="form-group">
          <label for="title" data-i18n="editor.title">Title</label>
          <input type="text" id="title" data-i18n-placeholder="editor.titlePlaceholder" placeholder="My first post">
        </div>
        <div class="form-group">
          <label for="slug" data-i18n="editor.slug">Slug</label>
          <input type="text" id="slug" data-i18n-placeholder="editor.slugPlaceholder" placeholder="my-first-post">
        </div>
        <div class="form-group">
          <label for="page-type" data-i18n="editor.pageType">Page Type</label>
          <select id="page-type" class="page-type-select">
            <option value="post" data-i18n="editor.pageTypePost">Post</option>
            <option value="page" data-i18n="editor.pageTypePage">Page</option>
          </select>
          <span id="page-type-hint" class="text-small text-muted"></span>
        </div>
      </div>
      <div class="rail-item">
        <span data-i18n="editor.blogTitle">Blog Title</span>
        <span id="title-bytes">0 B</span>
      </div>

      <!-- Title Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="title-override-enabled">
            <span data-i18n="editor.browserTabTitle">Browser Tab Title</span>
          </label>
          <p id="title-override-hint" class="override-hint" data-i18n="editor.browserTabTitleHint">âœ“ Using title only</p>
        </div>
        <div id="title-override-editor" class="override-editor">
          <div class="form-group">
            <label for="title-override" data-i18n="editor.browserTabTitle">Browser Tab Title</label>
            <input type="text" id="title-override" maxlength="100" placeholder="Custom browser tab title..." disabled>
          </div>
        </div>
      </div>
      <div class="rail-item" id="title-rail-item">
        <span data-i18n="editor.browserTabTitle">Browser Tab Title</span>
        <span id="browser-title-bytes">0 B</span>
      </div>

      <!-- Meta-Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="meta-enabled">
            <span data-i18n="settings.meta">Meta</span>
          </label>
          <p id="meta-global-hint" class="override-hint" data-i18n="settings.metaHint">Global SEO tags</p>
        </div>
        <div id="meta-editor" class="override-editor hidden">
          <div class="meta-row">
            <div class="form-group">
              <label for="meta-description" data-i18n="settings.metaDescription">Description</label>
              <input type="text" id="meta-description" maxlength="160" data-i18n-placeholder="settings.metaDescriptionPlaceholder" placeholder="Page description...">
            </div>
            <div class="form-group">
              <label for="meta-author" data-i18n="settings.metaAuthor">Author</label>
              <input type="text" id="meta-author" maxlength="100" data-i18n-placeholder="settings.metaAuthorPlaceholder" placeholder="Author name">
            </div>
          </div>
        </div>
      </div>
      <div class="rail-item" id="meta-rail-item">
        <span data-i18n="settings.meta">Meta</span>
        <span id="meta-bytes">0 B</span>
      </div>

      <!-- Navigation-Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="nav-enabled">
            <span data-i18n="settings.navigation">Navigation</span>
          </label>
          <p id="nav-global-hint" class="override-hint" data-i18n="settings.navigationHint">Navigation links</p>
        </div>
        <div id="nav-editor" class="override-editor hidden">
          <p class="text-small text-muted mb-1" data-i18n="settings.navigationHint">Navigation links (appear on every page)</p>
          <div class="nav-editor-row">
            <div id="nav-links" class="nav-links"></div>
            <button type="button" id="add-nav-link" class="btn btn-secondary" data-i18n="settings.navigationAddLink">+ Link</button>
          </div>
        </div>
      </div>
      <div class="rail-item" id="nav-rail-item">
        <span data-i18n="settings.navigation">Navigation</span>
        <span id="nav-bytes">0 B</span>
      </div>
    </div>
  </div>

  <!-- Card: Body -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title" data-i18n="editor.body">Body</h2>
    </div>
    <div class="card-body card-body-grid">
      <div class="block-editor-wrapper">
        <div id="block-editor" class="block-editor"></div>
        <div class="block-actions-row">
          <button type="button" id="add-block-btn" class="btn btn-secondary" data-i18n="editor.addBlock">+ Add Block</button>
          <div id="add-block-dropdown" class="add-block-dropdown hidden">
            <button type="button" data-type="paragraph" data-i18n="editor.blockParagraph">Paragraph</button>
            <button type="button" data-type="heading" data-level="2" data-i18n="editor.blockHeading">Heading</button>
            <button type="button" data-type="list" data-list-type="unordered" data-i18n="editor.blockList">List</button>
            <button type="button" data-type="divider" data-i18n="editor.blockDivider">Divider</button>
            <button type="button" data-type="bloglist" data-i18n="editor.blockBloglist">Bloglist</button>
          </div>
        </div>
      </div>
      <div class="rail-item rail-item-total" id="content-rail">
        <span data-i18n="editor.body">Body</span>
        <span id="cost-content-total">0 B</span>
      </div>
    </div>
  </div>

  <!-- Card: Footer -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title" data-i18n="editor.footer">Footer</h2>
    </div>
    <div class="card-body card-body-grid">
      <!-- Footer-Override -->
      <div class="override-section override-section-first">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="footer-enabled">
            <span data-i18n="settings.footerSection">Footer</span>
          </label>
          <p id="footer-global-hint" class="override-hint" data-i18n="settings.footerHint">Footer text</p>
        </div>
        <div id="footer-editor" class="override-editor hidden">
          <div class="footer-editor-row">
            <input type="text" id="footer-text" placeholder="Â© 2024 My Blog">
            <button type="button" id="insert-bytes-btn" class="btn btn-secondary" data-i18n="settings.footerBytesBtn">{{bytes}}</button>
          </div>
        </div>
      </div>
      <div class="rail-item">
        <span data-i18n="settings.footerSection">Footer</span>
        <span id="footer-bytes">0 B</span>
      </div>

      <!-- CSS Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="css-enabled">
            <span data-i18n="tabs.css">CSS</span>
          </label>
          <p id="css-global-hint" class="override-hint"></p>
        </div>
        <div id="css-editor" class="override-editor">
          <p class="css-warning-hint" data-i18n="settings.cssCustomHint">Custom CSS rules (embedded in every page)</p>
          <textarea id="css-rules" rows="10" data-i18n-placeholder="settings.cssCustom" placeholder="/* Additional CSS */"></textarea>
        </div>
      </div>
      <div class="rail-item">
        <span data-i18n="tabs.css">CSS</span>
        <span id="css-bytes">0 B</span>
      </div>
    </div>
  </div>

  <!-- Link Edit Popup for Navigation -->
  <div id="nav-link-popup" class="nav-link-popup hidden">
    <div class="popup-content">
      <div class="form-group">
        <label data-i18n="linkPopup.text">Text</label>
        <input type="text" id="nav-link-text" data-i18n-placeholder="linkPopup.textPlaceholder" placeholder="Home">
      </div>
      <div class="form-group">
        <label data-i18n="linkPopup.target">Target</label>
        <input type="text" id="nav-link-href" data-i18n-placeholder="linkPopup.targetPlaceholder" placeholder="/">
      </div>
      <div class="popup-actions">
        <button type="button" id="nav-link-save" class="btn btn-primary" data-i18n="linkPopup.save">OK</button>
        <button type="button" id="nav-link-delete" class="btn btn-danger" data-i18n="linkPopup.delete">Delete</button>
        <button type="button" id="nav-link-cancel" class="btn btn-secondary" data-i18n="linkPopup.cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Floating Format Toolbar (disabled - using inline buttons in block header)
  <div id="format-toolbar" class="format-toolbar hidden">
    <button type="button" data-cmd="bold" title="Bold"><b>B</b></button>
    <button type="button" data-cmd="italic" title="Italic"><i>I</i></button>
    <button type="button" data-cmd="underline" title="Underline"><u>U</u></button>
    <button type="button" data-cmd="strikethrough" title="Strikethrough"><s>S</s></button>
    <button type="button" data-cmd="code" title="Code"><code>&lt;&gt;</code></button>
    <button type="button" data-cmd="link" title="Link">ðŸ”—</button>
  </div>
  -->

  <!-- Link Popup for content -->
  <div id="link-popup" class="link-popup hidden">
    <div class="link-prefix-buttons">
      <button type="button" class="link-prefix-btn" data-prefix="https://" title="URL">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
      </button>
      <button type="button" class="link-prefix-btn" data-prefix="mailto:" title="E-Mail">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
      </button>
      <button type="button" class="link-prefix-btn" data-prefix="tel:" title="Telefon">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
      </button>
    </div>
    <input type="text" id="link-href" placeholder="/path or #anchor">
    <button type="button" id="link-apply" class="btn btn-primary">OK</button>
    <button type="button" id="link-cancel" class="btn btn-secondary">Ã—</button>
  </div>

  <!-- Modal System -->
  <div id="modal-backdrop" class="modal-backdrop hidden"></div>
  <div id="modal" class="modal hidden">
    <div class="modal-content">
      <p id="modal-message"></p>
      <div id="modal-actions" class="popup-actions"></div>
    </div>
  </div>

  <!-- Card: Build -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title">Build</h2>
    </div>
    <div class="card-body card-body-with-rail">
      <div class="card-content">
        <div class="breakdown-table">
          <div class="breakdown-row">
            <span>Base</span>
            <span id="breakdown-base">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Title</span>
            <span id="breakdown-title">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Favicon</span>
            <span id="breakdown-favicon">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Navigation</span>
            <span id="breakdown-nav">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Meta</span>
            <span id="breakdown-meta">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Footer</span>
            <span id="breakdown-footer">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>CSS</span>
            <span id="breakdown-css">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Content</span>
            <span id="breakdown-content">0 B</span>
          </div>
          <div class="breakdown-row breakdown-row-total">
            <span>Total</span>
            <span id="breakdown-total">0 B / 14.336 B</span>
          </div>
        </div>
      </div>
      <div class="card-rail build-rail">
        <div class="build-progress">
          <div class="pie-chart" id="pie-chart">
            <span class="pie-percent" id="pie-percent">0%</span>
          </div>
          <div class="pie-legend">
            <div class="pie-legend-item">
              <span class="pie-dot pie-dot-overhead"></span>
              <span>Overhead</span>
            </div>
            <div class="pie-legend-item">
              <span class="pie-dot pie-dot-content"></span>
              <span>Content</span>
            </div>
            <div class="pie-legend-item">
              <span class="pie-dot pie-dot-free"></span>
              <span>Free</span>
            </div>
          </div>
        </div>
        <button id="publish-btn" class="btn btn-primary build-publish-btn" data-i18n="editor.buildPublish">Build & Publish</button>
      </div>
    </div>
  </div>

  <!-- Live CSS Container -->
  <style id="live-css"></style>

  <script type="module" src="app.js"></script>
  <script type="module">
    // Import compiler (browser bundle)
    import * as Compiler from './compiler.browser.js';

    (async function () {
      // Wait for i18n to be ready
      await i18nReady();

      // Check if setup is complete
      const status = await App.getSetupStatus();
      if (!status.setupComplete) {
        window.location.href = '/admin/setup';
        return;
      }

      // Check auth
      const config = await App.getConfig();
      if (config.authEnabled && !(await App.isLoggedIn())) {
        window.location.href = 'index.html';
        return;
      }

      // Load settings with global header/footer/CSS
      const settings = await App.getSettings();
      window.globalConfig = settings;

      // Hide loading overlay
      document.getElementById('loading-overlay')?.remove();

      // Logout handler
      document.getElementById('logout-btn').addEventListener('click', async (e) => {
        e.preventDefault();
        await App.logout();
        window.location.href = '/admin/login.html';
      });

      // Elements
      const pageTypeSelect = document.getElementById('page-type');
      const pageTypeHint = document.getElementById('page-type-hint');
      const titleInput = document.getElementById('title');
      const slugInput = document.getElementById('slug');
      const blockEditor = document.getElementById('block-editor');
      const addBlockBtn = document.getElementById('add-block-btn');
      const addBlockDropdown = document.getElementById('add-block-dropdown');
      const formatToolbar = document.getElementById('format-toolbar');
      const linkPopup = document.getElementById('link-popup');
      const linkHrefInput = document.getElementById('link-href');
      const linkApplyBtn = document.getElementById('link-apply');
      const linkCancelBtn = document.getElementById('link-cancel');
      const navEnabled = document.getElementById('nav-enabled');
      const navEditor = document.getElementById('nav-editor');
      const navGlobalHint = document.getElementById('nav-global-hint');
      const navLinks = document.getElementById('nav-links');
      const addNavLinkBtn = document.getElementById('add-nav-link');
      const navLinkPopup = document.getElementById('nav-link-popup');
      const navLinkText = document.getElementById('nav-link-text');
      const navLinkHref = document.getElementById('nav-link-href');
      const navLinkSave = document.getElementById('nav-link-save');
      const navLinkDelete = document.getElementById('nav-link-delete');
      const navLinkCancel = document.getElementById('nav-link-cancel');
      const footerEnabled = document.getElementById('footer-enabled');
      const footerEditor = document.getElementById('footer-editor');
      const footerGlobalHint = document.getElementById('footer-global-hint');
      const footerText = document.getElementById('footer-text');
      const titleOverrideEnabled = document.getElementById('title-override-enabled');
      const titleOverrideEditor = document.getElementById('title-override-editor');
      const titleOverrideHint = document.getElementById('title-override-hint');
      const titleOverrideInput = document.getElementById('title-override');
      const metaEnabled = document.getElementById('meta-enabled');
      const metaEditor = document.getElementById('meta-editor');
      const metaGlobalHint = document.getElementById('meta-global-hint');
      const metaDescription = document.getElementById('meta-description');
      const metaAuthor = document.getElementById('meta-author');
      const cssEnabled = document.getElementById('css-enabled');
      const cssEditor = document.getElementById('css-editor');
      const cssGlobalHint = document.getElementById('css-global-hint');
      const cssRules = document.getElementById('css-rules');
      const liveCSS = document.getElementById('live-css');
      const publishBtn = document.getElementById('publish-btn');

      // Byte display elements
      const costContentTotal = document.getElementById('cost-content-total');
      const contentRail = document.getElementById('content-rail');
      const titleBytesEl = document.getElementById('title-bytes');
      const browserTitleBytesEl = document.getElementById('browser-title-bytes');
      const navBytesEl = document.getElementById('nav-bytes');
      const metaBytesEl = document.getElementById('meta-bytes');
      const footerBytesEl = document.getElementById('footer-bytes');
      const cssBytesEl = document.getElementById('css-bytes');

      // Build Card elements
      const breakdownBase = document.getElementById('breakdown-base');
      const breakdownTitle = document.getElementById('breakdown-title');
      const breakdownFavicon = document.getElementById('breakdown-favicon');
      const breakdownNav = document.getElementById('breakdown-nav');
      const breakdownMeta = document.getElementById('breakdown-meta');
      const breakdownFooter = document.getElementById('breakdown-footer');
      const breakdownCss = document.getElementById('breakdown-css');
      const breakdownContent = document.getElementById('breakdown-content');
      const breakdownTotal = document.getElementById('breakdown-total');
      const pieChart = document.getElementById('pie-chart');
      const piePercent = document.getElementById('pie-percent');
      const pieContentDot = document.querySelector('.pie-dot-content');

      // State
      let savedSelection = null;
      let editingNavLink = null; // The chip element being edited

      // ============ AUTO-SAVE ============

      const AUTOSAVE_KEY = 'editor-autosave';

      // Get current context from URL
      function getCurrentContext() {
        const params = new URLSearchParams(window.location.search);
        const editSlug = params.get('edit');
        return editSlug ? { mode: 'edit', slug: editSlug } : { mode: 'new', slug: null };
      }

      function saveToLocalStorage() {
        const context = getCurrentContext();
        try {
          const data = {
            // Context for validation on restore
            context,
            // Editor state
            title: titleInput.value,
            slug: slugInput.value,
            pageType: pageTypeSelect.value,
            blocks: [],
            titleOverrideEnabled: titleOverrideEnabled.checked,
            titleOverride: titleOverrideEnabled.checked ? titleOverrideInput.value : null,
            navEnabled: navEnabled.checked,
            navigation: navEnabled.checked ? getNavigationItems() : null,
            footerEnabled: footerEnabled.checked,
            footer: footerEnabled.checked ? footerText.value : null,
            metaEnabled: metaEnabled.checked,
            metaDescription: metaDescription.value,
            metaAuthor: metaAuthor.value,
            cssEnabled: cssEnabled.checked,
            css: cssEnabled.checked ? cssRules.value : null,
            timestamp: Date.now()
          };

          // Save blocks
          const blocks = blockEditor.querySelectorAll('.block-item');
          blocks.forEach(blockItem => {
            const type = blockItem.dataset.type;
            const level = blockItem.dataset.level || null;
            const content = blockItem.querySelector('.block-content');
            if (content) {
              data.blocks.push({
                type,
                level,
                html: content.innerHTML
              });
            }
          });

          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
        } catch (err) {
          console.warn('Failed to auto-save:', err);
        }
      }

      function loadFromLocalStorage() {
        try {
          const saved = localStorage.getItem(AUTOSAVE_KEY);
          if (!saved) return false;

          const data = JSON.parse(saved);
          const currentContext = getCurrentContext();

          // Only restore if context matches (same mode and slug)
          if (data.context?.mode !== currentContext.mode ||
              data.context?.slug !== currentContext.slug) {
            return false;
          }

          // Check if data is not too old (older than 7 days)
          const age = Date.now() - (data.timestamp || 0);
          if (age > 7 * 24 * 60 * 60 * 1000) {
            localStorage.removeItem(AUTOSAVE_KEY);
            return false;
          }

          // Restore basic fields
          titleInput.value = data.title || '';
          slugInput.value = data.slug || '';
          pageTypeSelect.value = data.pageType || 'post';

          // Restore blocks
          if (data.blocks && data.blocks.length > 0) {
            blockEditor.innerHTML = '';
            data.blocks.forEach(block => {
              const level = block.level || null;
              const blockElement = createBlockElement(block.type, level, block.html || '');
              blockEditor.appendChild(blockElement);
            });
          }

          // Restore title override
          if (data.titleOverrideEnabled) {
            titleOverrideEnabled.checked = true;
            titleOverrideEnabled.dispatchEvent(new Event('change'));
            titleOverrideInput.value = data.titleOverride || '';
          }

          // Restore navigation
          if (data.navEnabled) {
            navEnabled.checked = true;
            navEnabled.dispatchEvent(new Event('change'));
            if (data.navigation && data.navigation.length > 0) {
              navLinks.innerHTML = '';
              data.navigation.forEach(link => {
                navLinks.appendChild(createNavChip(link.text, link.href));
              });
            }
          }

          // Restore footer
          if (data.footerEnabled) {
            footerEnabled.checked = true;
            footerEnabled.dispatchEvent(new Event('change'));
            footerText.value = data.footer || '';
          }

          // Restore meta
          if (data.metaEnabled) {
            metaEnabled.checked = true;
            metaEnabled.dispatchEvent(new Event('change'));
            metaDescription.value = data.metaDescription || '';
            metaAuthor.value = data.metaAuthor || '';
          }

          // Restore CSS
          if (data.cssEnabled) {
            cssEnabled.checked = true;
            cssEnabled.dispatchEvent(new Event('change'));
            cssRules.value = data.css || '';
          }

          // Update page title with restored slug (for new mode)
          updatePageTitleSlug();

          return true;
        } catch (err) {
          console.warn('Failed to restore auto-save:', err);
          return false;
        }
      }

      function clearAutoSave() {
        try {
          localStorage.removeItem(AUTOSAVE_KEY);
        } catch (err) {
          console.warn('Failed to clear auto-save:', err);
        }
      }

      // ============ EDIT MODE (Source Editing) ============

      let isEditMode = false;
      let editingSlug = null;

      // Update page title with current slug (for new mode)
      function updatePageTitleSlug() {
        if (isEditMode) return; // Don't update in edit mode
        const pageTitle = document.getElementById('page-title');
        const slug = slugInput.value.trim();
        if (slug) {
          pageTitle.innerHTML = `New <span style="font-weight: 400; color: var(--text-secondary);">/ ${slug}</span>`;
        } else {
          pageTitle.textContent = 'New';
        }
      }

      // Convert inline nodes (compiler format) to HTML for editor
      function inlineNodesToHtml(nodes) {
        if (!nodes || !Array.isArray(nodes)) return '';
        return nodes.map(node => {
          switch (node.type) {
            case 'text':
              // Escape HTML entities
              return node.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            case 'linebreak':
              return '<br>';
            case 'bold':
              return `<b>${inlineNodesToHtml(node.children)}</b>`;
            case 'italic':
              return `<i>${inlineNodesToHtml(node.children)}</i>`;
            case 'underline':
              return `<u>${inlineNodesToHtml(node.children)}</u>`;
            case 'strikethrough':
              return `<s>${inlineNodesToHtml(node.children)}</s>`;
            case 'code':
              return `<code>${inlineNodesToHtml(node.children)}</code>`;
            case 'link':
              return `<a href="${node.href}">${inlineNodesToHtml(node.children)}</a>`;
            default:
              return inlineNodesToHtml(node.children);
          }
        }).join('');
      }

      // Load editor state from source JSON (compiler format)
      function loadFromSource(sourceData) {
        // Restore basic fields
        titleInput.value = sourceData.title || '';
        slugInput.value = sourceData.slug || '';
        pageTypeSelect.value = sourceData.pageType || 'post';

        // Restore blocks from content array
        blockEditor.innerHTML = '';
        if (sourceData.content && sourceData.content.length > 0) {
          sourceData.content.forEach(block => {
            let blockEl;
            if (block.type === 'bloglist') {
              // Bloglist options are now configured globally in Settings â†’ Bloglist
              blockEl = createBlockElement('bloglist');
            } else if (block.type === 'divider') {
              blockEl = createBlockElement('divider');
            } else if (block.type === 'codeblock') {
              blockEl = createBlockElement('codeblock', null, block.content || '');
            } else if (block.type === 'unordered-list' || block.type === 'ordered-list') {
              const listType = block.type === 'ordered-list' ? 'ordered' : 'unordered';
              blockEl = createBlockElement('list', null, '', listType);
              // Populate list items
              const listEl = blockEl.querySelector('.editable-list');
              if (listEl && block.items) {
                listEl.innerHTML = '';
                block.items.forEach(item => {
                  const li = document.createElement('li');
                  li.contentEditable = 'true';
                  li.innerHTML = inlineNodesToHtml(item.children);
                  listEl.appendChild(li);
                });
                setupListKeyHandlers(listEl);
              }
            } else if (block.type === 'heading') {
              const html = inlineNodesToHtml(block.children);
              blockEl = createBlockElement('heading', block.level, html);
            } else if (block.type === 'blockquote') {
              const html = inlineNodesToHtml(block.children);
              blockEl = createBlockElement('blockquote', null, html);
            } else {
              // paragraph
              const html = inlineNodesToHtml(block.children);
              blockEl = createBlockElement('paragraph', null, html);
            }
            blockEditor.appendChild(blockEl);
          });
        } else {
          // Add empty paragraph if no content
          blockEditor.appendChild(createBlockElement('paragraph'));
        }

        // Restore title override
        if (sourceData.titleOverride && typeof sourceData.titleOverride === 'object' && sourceData.titleOverride.enabled) {
          titleOverrideEnabled.checked = true;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
          titleOverrideInput.value = sourceData.titleOverride.title || '';
        } else if (typeof sourceData.titleOverride === 'string' && sourceData.titleOverride) {
          // Legacy format - titleOverride is just a string
          titleOverrideEnabled.checked = true;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
          titleOverrideInput.value = sourceData.titleOverride;
        } else {
          titleOverrideEnabled.checked = false;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
        }

        // Restore navigation
        if (sourceData.navigation && sourceData.navigation.items && sourceData.navigation.items.length > 0) {
          navEnabled.checked = true;
          navEnabled.dispatchEvent(new Event('change'));
          navLinks.innerHTML = '';
          sourceData.navigation.items.forEach(link => {
            navLinks.appendChild(createNavChip(link.text, link.href));
          });
        } else {
          navEnabled.checked = false;
          navEnabled.dispatchEvent(new Event('change'));
          loadGlobalNavigation();
        }

        // Restore footer
        if (sourceData.footer && sourceData.footer.content) {
          footerEnabled.checked = true;
          footerEnabled.dispatchEvent(new Event('change'));
          footerText.value = sourceData.footer.content;
        } else {
          footerEnabled.checked = false;
          footerEnabled.dispatchEvent(new Event('change'));
          loadGlobalFooter();
        }

        // Restore meta
        if (sourceData.meta) {
          metaEnabled.checked = true;
          metaEnabled.dispatchEvent(new Event('change'));
          metaDescription.value = sourceData.meta.description || '';
          metaAuthor.value = sourceData.meta.author || '';
        } else {
          metaEnabled.checked = false;
          metaEnabled.dispatchEvent(new Event('change'));
          loadGlobalMeta();
        }

        // Restore CSS
        if (sourceData.css && sourceData.css.rules) {
          cssEnabled.checked = true;
          cssEnabled.dispatchEvent(new Event('change'));
          cssRules.value = sourceData.css.rules;
        } else {
          cssEnabled.checked = false;
          cssEnabled.dispatchEvent(new Event('change'));
          loadGlobalCSS();
        }
      }

      // ============ PAGE TYPE ============

      pageTypeSelect.addEventListener('change', () => {
        const type = pageTypeSelect.value;
        if (type === 'page') {
          pageTypeHint.textContent = '(not in feed)';
        } else {
          pageTypeHint.textContent = '';
        }
      });

      // ============ NAVIGATION EDITOR ============

      // Load global navigation into disabled fields
      function loadGlobalNavigation() {
        navLinks.innerHTML = '';
        if (window.globalConfig?.header?.links) {
          window.globalConfig.header.links.forEach(link => {
            navLinks.appendChild(createNavChip(link.text, link.href));
          });
        }
      }

      navEnabled.addEventListener('change', () => {
        navGlobalHint.classList.toggle('hidden', navEnabled.checked);

        // Toggle disabled state
        const chips = navLinks.querySelectorAll('.nav-chip');
        chips.forEach(chip => {
          chip.style.pointerEvents = navEnabled.checked ? 'auto' : 'none';
          chip.style.opacity = navEnabled.checked ? '1' : '0.6';
        });
        addNavLinkBtn.disabled = !navEnabled.checked;
      });

      function createNavChip(text, href) {
        const chip = document.createElement('span');
        chip.className = 'nav-chip';
        chip.dataset.href = href;
        chip.textContent = text;
        chip.draggable = true;
        chip.addEventListener('click', () => editNavLink(chip));

        // Drag & Drop
        chip.addEventListener('dragstart', (e) => {
          chip.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
        });

        chip.addEventListener('dragend', () => {
          chip.classList.remove('dragging');
          navLinks.querySelectorAll('.nav-chip').forEach(c => c.classList.remove('drag-over'));
        });

        chip.addEventListener('dragover', (e) => {
          e.preventDefault();
          const dragging = navLinks.querySelector('.dragging');
          if (dragging && dragging !== chip) {
            chip.classList.add('drag-over');
          }
        });

        chip.addEventListener('dragleave', () => {
          chip.classList.remove('drag-over');
        });

        chip.addEventListener('drop', (e) => {
          e.preventDefault();
          const dragging = navLinks.querySelector('.dragging');
          if (dragging && dragging !== chip) {
            const allChips = [...navLinks.querySelectorAll('.nav-chip')];
            const dragIndex = allChips.indexOf(dragging);
            const dropIndex = allChips.indexOf(chip);
            if (dragIndex < dropIndex) {
              chip.after(dragging);
            } else {
              chip.before(dragging);
            }
          }
          chip.classList.remove('drag-over');
        });

        return chip;
      }

      function editNavLink(chip) {
        editingNavLink = chip;
        navLinkText.value = chip.textContent;
        navLinkHref.value = chip.dataset.href;
        navLinkDelete.classList.remove('hidden');
        navLinkPopup.classList.remove('hidden');
        navLinkText.focus();
      }

      addNavLinkBtn.addEventListener('click', () => {
        editingNavLink = null;
        navLinkText.value = '';
        navLinkHref.value = '';
        navLinkDelete.classList.add('hidden');
        navLinkPopup.classList.remove('hidden');
        navLinkText.focus();
      });

      navLinkSave.addEventListener('click', () => {
        const text = navLinkText.value.trim();
        const href = navLinkHref.value.trim();
        if (!text || !href) return;

        if (editingNavLink) {
          editingNavLink.textContent = text;
          editingNavLink.dataset.href = href;
        } else {
          navLinks.appendChild(createNavChip(text, href));
        }
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      navLinkDelete.addEventListener('click', () => {
        if (editingNavLink) {
          editingNavLink.remove();
        }
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      navLinkCancel.addEventListener('click', () => {
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      // ============ FOOTER EDITOR ============

      const insertBytesBtn = document.getElementById('insert-bytes-btn');

      // Load global footer into disabled field
      function loadGlobalFooter() {
        if (window.globalConfig?.footer?.content) {
          footerText.value = window.globalConfig.footer.content;
        }
      }

      footerEnabled.addEventListener('change', () => {
        footerGlobalHint.classList.toggle('hidden', footerEnabled.checked);
        footerText.disabled = !footerEnabled.checked;
        insertBytesBtn.disabled = !footerEnabled.checked;
      });

      // ============ META EDITOR ============

      // Load global meta into disabled fields
      function loadGlobalMeta() {
        if (window.globalConfig?.meta?.description) {
          metaDescription.value = window.globalConfig.meta.description;
        }
        if (window.globalConfig?.meta?.author) {
          metaAuthor.value = window.globalConfig.meta.author;
        }
      }

      metaEnabled.addEventListener('change', () => {
        metaGlobalHint.classList.toggle('hidden', metaEnabled.checked);
        metaDescription.disabled = !metaEnabled.checked;
        metaAuthor.disabled = !metaEnabled.checked;
      });

      // ============ TITLE OVERRIDE EDITOR ============

      function updateTitleOverrideHint() {
        const siteTitleEnabled = window.globalConfig?.siteTitleEnabled !== false;
        const siteTitleText = window.globalConfig?.siteTitle;
        if (siteTitleEnabled && siteTitleText) {
          titleOverrideHint.textContent = `âœ“ Using: Title | ${siteTitleText}`;
        } else {
          titleOverrideHint.textContent = 'âœ“ Using title only';
        }
      }

      titleOverrideEnabled.addEventListener('change', () => {
        titleOverrideHint.classList.toggle('hidden', titleOverrideEnabled.checked);
        titleOverrideInput.disabled = !titleOverrideEnabled.checked;
        updateTitleBytes();
      });

      titleOverrideInput.addEventListener('input', () => {
        updateTitleBytes();
      });

      insertBytesBtn.addEventListener('click', () => {
        const cursorPos = footerText.selectionStart;
        const textBefore = footerText.value.substring(0, cursorPos);
        const textAfter = footerText.value.substring(cursorPos);
        footerText.value = textBefore + '{{bytes}}' + textAfter;
        footerText.focus();
        footerText.setSelectionRange(cursorPos + 9, cursorPos + 9);
        debouncedPreview();
      });

      // ============ CSS EDITOR ============

      function getThemeDisplayName(cssMode) {
        const names = {
          'default': 'CMS Default Theme',
          'light': 'CMS Light Theme',
          'dark': 'CMS Dark Theme',
          'custom': 'Custom CSS'
        };
        return names[cssMode] || cssMode || 'CMS Default Theme';
      }

      // Don't load global CSS - this field is for ADDITIONAL CSS only
      function loadGlobalCSS() {
        // Leave empty - this textarea is for additional CSS only
        // Global CSS is already included in the base template

        // Update hint with theme name
        const themeName = getThemeDisplayName(window.globalConfig?.cssMode);
        cssGlobalHint.textContent = `âœ“ ${themeName} is used globally`;
      }

      cssEnabled.addEventListener('change', () => {
        cssGlobalHint.classList.toggle('hidden', cssEnabled.checked);
        cssRules.disabled = !cssEnabled.checked;
      });

      // ============ LIVE CSS ============

      cssRules.addEventListener('input', () => {
        applyLiveCSS();
      });

      function applyLiveCSS() {
        const css = cssRules.value.trim();
        // Scope CSS to block-editor to avoid breaking admin UI
        // Simple approach: prefix all rules with .block-editor
        if (!css) {
          liveCSS.textContent = '';
          return;
        }

        // Basic scoping - wrap in .block-editor context
        // This won't handle all edge cases but works for simple rules
        try {
          const scopedCSS = css.replace(/([^{}]+)\{/g, (match, selector) => {
            const selectors = selector.split(',').map(s => {
              s = s.trim();
              if (s.startsWith('@') || s.startsWith('from') || s.startsWith('to') || /^\d+%$/.test(s)) {
                return s;
              }
              if (s === 'body' || s === 'html') {
                return '.block-editor';
              }
              return `.block-editor ${s}`;
            }).join(', ');
            return selectors + ' {';
          });
          liveCSS.textContent = scopedCSS;
        } catch (e) {
          // Invalid CSS, ignore
        }
      }

      // ============ AUTO-SLUG ============

      titleInput.addEventListener('input', () => {
        if (!slugInput.dataset.manual) {
          slugInput.value = App.slugify(titleInput.value);
          updatePageTitleSlug();
        }
        updateTitleBytes();
      });

      slugInput.addEventListener('input', () => {
        slugInput.dataset.manual = 'true';
        updatePageTitleSlug();
      });

      // ============ BLOCK EDITOR ============

      function setupListKeyHandlers(listEl) {
        listEl.addEventListener('keydown', (e) => {
          const li = e.target.closest('li');
          if (!li) return;

          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const newLi = document.createElement('li');
            newLi.contentEditable = 'true';
            newLi.dataset.placeholder = 'List item...';
            li.after(newLi);
            newLi.focus();
            debouncedPreview();
          } else if (e.key === 'Backspace' && li.innerHTML === '' && listEl.children.length > 1) {
            e.preventDefault();
            const prevLi = li.previousElementSibling;
            li.remove();
            if (prevLi) {
              prevLi.focus();
              // Move cursor to end
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(prevLi);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
            }
            debouncedPreview();
          }
        });
      }

      function createBlockElement(type, level, initialHtml = '', listType = null) {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.dataset.type = type;
        if (level) block.dataset.level = level;
        if (listType) block.dataset.listType = listType;

        // Block header with type selector and actions
        const header = document.createElement('div');
        header.className = 'block-header';

        // Type selector
        if (type === 'paragraph' || type === 'blockquote' || type === 'codeblock') {
          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="paragraph">Paragraph</option>
            <option value="blockquote">Blockquote</option>
            <option value="codeblock">Code Block</option>
          `;
          typeSelect.value = type;
          typeSelect.addEventListener('change', () => {
            const newType = typeSelect.value;
            const oldType = block.dataset.type;
            block.dataset.type = newType;

            // Handle content conversion
            const content = block.querySelector('.block-content');
            if (oldType === 'codeblock' && newType !== 'codeblock') {
              // From codeblock to rich text - convert plain text
              content.contentEditable = 'true';
              content.classList.remove('block-codeblock');
              content.dataset.placeholder = newType === 'blockquote' ? 'Quote...' : 'Enter text...';
              // Show format buttons
              const formatBtns = block.querySelector('.block-format-buttons');
              if (formatBtns) formatBtns.style.display = '';
            } else if (oldType !== 'codeblock' && newType === 'codeblock') {
              // From rich text to codeblock - strip HTML
              content.textContent = content.textContent;
              content.contentEditable = 'true';
              content.classList.add('block-codeblock');
              content.dataset.placeholder = 'Code...';
              // Hide format buttons
              const formatBtns = block.querySelector('.block-format-buttons');
              if (formatBtns) formatBtns.style.display = 'none';
            } else {
              // Just update placeholder
              content.dataset.placeholder = newType === 'blockquote' ? 'Quote...' : newType === 'codeblock' ? 'Code...' : 'Enter text...';
            }

            updateBlockStyling(block);
            updateCostRail();
            debouncedPreview();
          });
          header.appendChild(typeSelect);
        } else if (type === 'heading') {
          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="1">H1</option>
            <option value="2">H2</option>
            <option value="3">H3</option>
            <option value="4">H4</option>
            <option value="5">H5</option>
            <option value="6">H6</option>
          `;
          typeSelect.value = level || '2';
          typeSelect.addEventListener('change', () => {
            block.dataset.level = typeSelect.value;
            updateBlockStyling(block);
            updateCostRail();
            debouncedPreview();
          });
          header.appendChild(typeSelect);
        } else if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
          // Normalize type for new blocks - use passed listType or derive from legacy type
          const effectiveListType = listType || (type === 'ordered-list' ? 'ordered' : 'unordered');
          block.dataset.type = 'list';
          block.dataset.listType = effectiveListType;

          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="unordered">Unordered List</option>
            <option value="ordered">Ordered List</option>
          `;
          typeSelect.value = effectiveListType;
          typeSelect.addEventListener('change', () => {
            const newListType = typeSelect.value;
            block.dataset.listType = newListType;
            // Update list element tag
            const oldList = block.querySelector('.editable-list');
            if (oldList) {
              const newTag = newListType === 'ordered' ? 'ol' : 'ul';
              const newList = document.createElement(newTag);
              newList.className = 'editable-list';
              // Move all children
              while (oldList.firstChild) {
                newList.appendChild(oldList.firstChild);
              }
              // Copy event listeners by replacing
              oldList.replaceWith(newList);
              setupListKeyHandlers(newList);
            }
            updateCostRail();
            debouncedPreview();
          });
          header.appendChild(typeSelect);
        } else {
          // Bloglist or Divider - just a label
          const label = document.createElement('span');
          label.className = 'block-type-label';
          label.textContent = type === 'divider' ? 'Divider' : 'Bloglist';
          header.appendChild(label);
        }

        // Format buttons (nur fÃ¼r rich-text BlÃ¶cke, nicht fÃ¼r bloglist, divider, codeblock)
        if (type !== 'bloglist' && type !== 'divider' && type !== 'codeblock') {
          const formatBtns = document.createElement('div');
          formatBtns.className = 'block-format-buttons';

          const formats = [
            { cmd: 'bold', label: 'B', title: 'Bold', style: 'font-weight:bold' },
            { cmd: 'italic', label: 'I', title: 'Italic', style: 'font-style:italic' },
            { cmd: 'underline', label: 'U', title: 'Underline', style: 'text-decoration:underline' },
            { cmd: 'strikethrough', label: 'S', title: 'Strikethrough', style: 'text-decoration:line-through' },
            { cmd: 'code', label: '<>', title: 'Code', style: 'font-family:monospace;font-size:11px' },
            { cmd: 'link', label: 'ðŸ”—', title: 'Link', style: '' }
          ];

          formats.forEach(fmt => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.innerHTML = `<span style="${fmt.style}">${fmt.label}</span>`;
            btn.title = fmt.title;
            btn.dataset.cmd = fmt.cmd;
            btn.addEventListener('click', () => handleFormatClick(fmt.cmd, block));
            formatBtns.appendChild(btn);
          });

          header.appendChild(formatBtns);
        }

        const actions = document.createElement('div');
        actions.className = 'block-item-actions';

        const upBtn = document.createElement('button');
        upBtn.type = 'button';
        upBtn.textContent = 'â†‘';
        upBtn.title = 'Move up';
        upBtn.addEventListener('click', () => moveBlock(block, -1));
        actions.appendChild(upBtn);

        const downBtn = document.createElement('button');
        downBtn.type = 'button';
        downBtn.textContent = 'â†“';
        downBtn.title = 'Move down';
        downBtn.addEventListener('click', () => moveBlock(block, 1));
        actions.appendChild(downBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'Delete';
        deleteBtn.addEventListener('click', () => block.remove());
        actions.appendChild(deleteBtn);

        header.appendChild(actions);

        // Byte indicator fÃ¼r diesen Block
        const byteIndicator = document.createElement('div');
        byteIndicator.className = 'block-byte-indicator';
        byteIndicator.textContent = '0 B';
        block.appendChild(byteIndicator);

        block.appendChild(header);

        // Content area
        const content = document.createElement('div');
        content.className = 'block-content';
        if (type === 'bloglist') {
          content.contentEditable = 'false';
          content.className = 'block-content block-bloglist';
          content.innerHTML = `
            <div class="bloglist-config">
              <div class="bloglist-info">
                <em style="color: #999;" data-i18n="editor.bloglistPlaceholder">Blog posts will be listed here automatically</em>
              </div>
              <div class="bloglist-settings-link">
                <a href="settings.html#bloglist" style="color: var(--text-secondary); font-size: 12px;" data-i18n="editor.bloglistSettingsLink">Configure in Settings â†’ Bloglist</a>
              </div>
            </div>
          `;
        } else if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
          content.className = 'block-content block-list';
          // Determine list tag from listType or legacy type
          const listType = block.dataset.listType || (type === 'ordered-list' ? 'ordered' : 'unordered');
          const listEl = document.createElement(listType === 'ordered' ? 'ol' : 'ul');
          listEl.className = 'editable-list';

          // Check if initialHtml contains a list (for restoring saved data)
          if (initialHtml && (initialHtml.includes('<li>') || initialHtml.includes('<li '))) {
            // Parse the saved HTML to extract list items
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = initialHtml;
            const existingList = tempDiv.querySelector('ul, ol');
            const existingItems = existingList ? existingList.querySelectorAll('li') : tempDiv.querySelectorAll('li');

            if (existingItems.length > 0) {
              existingItems.forEach(existingLi => {
                const li = document.createElement('li');
                li.contentEditable = 'true';
                li.dataset.placeholder = 'List item...';
                li.innerHTML = existingLi.innerHTML;
                listEl.appendChild(li);
              });
            } else {
              // Fallback: create empty item
              const li = document.createElement('li');
              li.contentEditable = 'true';
              li.dataset.placeholder = 'List item...';
              listEl.appendChild(li);
            }
          } else {
            // New list: create single empty item
            const li = document.createElement('li');
            li.contentEditable = 'true';
            li.dataset.placeholder = 'List item...';
            li.innerHTML = initialHtml || '';
            listEl.appendChild(li);
          }

          setupListKeyHandlers(listEl);
          content.appendChild(listEl);
        } else if (type === 'divider') {
          content.contentEditable = 'false';
          content.className = 'block-content block-divider';
          content.innerHTML = '<hr>';
        } else if (type === 'codeblock') {
          content.contentEditable = 'true';
          content.className = 'block-content block-codeblock';
          content.dataset.placeholder = 'Code...';
          content.textContent = initialHtml || '';
        } else if (type === 'blockquote') {
          content.contentEditable = 'true';
          content.dataset.placeholder = 'Quote...';
          content.innerHTML = initialHtml;
        } else {
          content.contentEditable = 'true';
          content.dataset.placeholder = type === 'heading' ? 'Heading...' : 'Enter text...';
          content.innerHTML = initialHtml;
        }
        block.appendChild(content);

        updateBlockStyling(block);
        return block;
      }

      function updateBlockStyling(block) {
        const content = block.querySelector('.block-content');
        const type = block.dataset.type;
        const level = block.dataset.level;

        // Reset styles
        content.style.fontSize = '';
        content.style.fontWeight = '';
        content.style.fontStyle = '';
        content.style.borderLeft = '';
        content.style.paddingLeft = '';

        if (type === 'heading') {
          content.style.fontWeight = 'bold';
          const sizes = { 1: '2rem', 2: '1.5rem', 3: '1.25rem', 4: '1.1rem', 5: '1rem', 6: '0.875rem' };
          content.style.fontSize = sizes[level] || '1rem';
          content.dataset.placeholder = 'Heading...';
        } else if (type === 'blockquote') {
          content.style.fontStyle = 'italic';
          content.style.borderLeft = '3px solid var(--border)';
          content.style.paddingLeft = '12px';
          content.dataset.placeholder = 'Quote...';
        } else if (type === 'codeblock') {
          content.dataset.placeholder = 'Code...';
        } else if (type !== 'bloglist' && type !== 'divider' && type !== 'list') {
          content.dataset.placeholder = 'Enter text...';
        }
      }

      function moveBlock(block, direction) {
        const blocks = Array.from(blockEditor.children);
        const index = blocks.indexOf(block);
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= blocks.length) return;

        if (direction < 0) {
          blockEditor.insertBefore(block, blocks[newIndex]);
        } else {
          blockEditor.insertBefore(block, blocks[newIndex].nextSibling);
        }
      }

      // ============ FORMAT BUTTONS ============

      function handleFormatClick(cmd, block) {
        // Save selection BEFORE anything else (clicking button may lose it)
        const sel = window.getSelection();
        const hasSelection = sel.rangeCount > 0 && !sel.isCollapsed;
        const currentRange = hasSelection ? sel.getRangeAt(0).cloneRange() : null;

        // For link command, we need a selection
        if (cmd === 'link') {
          if (!hasSelection) {
            alert('Bitte erst Text markieren');
            return;
          }
          savedSelection = currentRange;
          showLinkPopup();
          return;
        }

        // Focus the block content if not already focused
        const content = block.querySelector('.block-content');
        const listItem = block.querySelector('li[contenteditable="true"]');
        const editableEl = listItem || content;

        // Restore selection if we have one
        if (currentRange) {
          sel.removeAllRanges();
          sel.addRange(currentRange);
        } else if (!editableEl.contains(document.activeElement) && editableEl !== document.activeElement) {
          editableEl.focus();
        }

        if (cmd === 'bold') {
          document.execCommand('bold', false, null);
        } else if (cmd === 'italic') {
          document.execCommand('italic', false, null);
        } else if (cmd === 'underline') {
          document.execCommand('underline', false, null);
        } else if (cmd === 'strikethrough') {
          document.execCommand('strikeThrough', false, null);
        } else if (cmd === 'code') {
          wrapSelectionWithTag('code');
        }
        debouncedPreview();
      }

      // ============ FLOATING FORMAT TOOLBAR (disabled - using inline buttons) ============
      /*
      document.addEventListener('selectionchange', () => {
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) {
          formatToolbar.classList.add('hidden');
          return;
        }

        // Check if selection is within block editor
        const range = sel.getRangeAt(0);
        const container = range.commonAncestorContainer;
        const blockContent = container.nodeType === Node.TEXT_NODE
          ? container.parentElement.closest('.block-content')
          : container.closest('.block-content');

        if (!blockContent || !blockEditor.contains(blockContent)) {
          formatToolbar.classList.add('hidden');
          return;
        }

        // Position toolbar above selection
        const rect = range.getBoundingClientRect();
        formatToolbar.style.top = (rect.top + window.scrollY - 40) + 'px';
        formatToolbar.style.left = (rect.left + window.scrollX + rect.width / 2 - 50) + 'px';
        formatToolbar.classList.remove('hidden');
      });

      formatToolbar.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const cmd = btn.dataset.cmd;
        if (cmd === 'bold') {
          document.execCommand('bold', false, null);
        } else if (cmd === 'italic') {
          document.execCommand('italic', false, null);
        } else if (cmd === 'underline') {
          document.execCommand('underline', false, null);
        } else if (cmd === 'strikethrough') {
          document.execCommand('strikeThrough', false, null);
        } else if (cmd === 'code') {
          wrapSelectionWithTag('code');
        } else if (cmd === 'link') {
          showLinkPopup();
        }
      });
      */

      function wrapSelectionWithTag(tagName) {
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) return;

        const range = sel.getRangeAt(0);
        const selectedText = range.toString();

        // Check if already wrapped in this tag
        const parentTag = sel.anchorNode.parentElement.closest(tagName);
        if (parentTag) {
          // Unwrap: replace tag with its contents
          const parent = parentTag.parentNode;
          while (parentTag.firstChild) {
            parent.insertBefore(parentTag.firstChild, parentTag);
          }
          parent.removeChild(parentTag);
        } else {
          // Wrap selection
          const wrapper = document.createElement(tagName);
          range.surroundContents(wrapper);
        }

        debouncedPreview();
      }

      // ============ LINK POPUP ============

      function showLinkPopup() {
        // savedSelection should already be set by handleFormatClick
        if (!savedSelection) return;

        // Check if selection is inside a link
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(savedSelection);
        const parentLink = sel.anchorNode?.parentElement?.closest('a');
        const existingHref = parentLink ? parentLink.getAttribute('href') : '';
        linkHrefInput.value = existingHref;

        // Reset prefix buttons and set active based on existing href
        linkPopup.querySelectorAll('.link-prefix-btn').forEach(btn => {
          const prefix = btn.dataset.prefix;
          if (existingHref.startsWith(prefix)) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });

        // Update placeholder based on existing prefix
        if (existingHref.startsWith('https://') || existingHref.startsWith('http://')) {
          linkHrefInput.placeholder = 'www.example.com';
        } else if (existingHref.startsWith('mailto:')) {
          linkHrefInput.placeholder = 'name@example.com';
        } else if (existingHref.startsWith('tel:')) {
          linkHrefInput.placeholder = '+49 123 456789';
        } else {
          linkHrefInput.placeholder = '/path or #anchor';
        }

        const rect = savedSelection.getBoundingClientRect();
        linkPopup.style.top = (rect.bottom + window.scrollY + 5) + 'px';
        linkPopup.style.left = (rect.left + window.scrollX) + 'px';
        linkPopup.classList.remove('hidden');
        linkHrefInput.focus();
      }

      linkApplyBtn.addEventListener('click', () => {
        const href = linkHrefInput.value.trim();
        if (!href) {
          linkPopup.classList.add('hidden');
          return;
        }

        // Validate href pattern (same as compiler validation)
        const hrefPattern = /^(\/[a-z0-9._/-]*|#[a-z0-9-]*|[a-z0-9-]+\.html|https?:\/\/[^\s]+|mailto:[^\s]+|tel:[^\s]+)$/i;
        if (!hrefPattern.test(href)) {
          // Give specific hint based on what user likely meant
          let hint;
          if (/^www\./i.test(href) || /\.(com|de|org|net|io|dev|at|ch)$/i.test(href)) {
            hint = `URLs mÃ¼ssen mit https:// beginnen: https://${href}`;
          } else if (/@/.test(href) && !href.startsWith('mailto:')) {
            hint = `E-Mail-Links mÃ¼ssen mit mailto: beginnen: mailto:${href}`;
          } else if (/^[\d\s+()-]+$/.test(href)) {
            hint = `Telefon-Links mÃ¼ssen mit tel: beginnen: tel:${href.replace(/\s/g, '')}`;
          } else {
            hint = 'UngÃ¼ltiges Link-Format';
          }
          Modal.info(hint);
          return;
        }

        if (savedSelection) {
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(savedSelection);
          document.execCommand('createLink', false, href);
        }
        linkPopup.classList.add('hidden');
        savedSelection = null;
        debouncedPreview();
      });

      linkCancelBtn.addEventListener('click', () => {
        linkPopup.classList.add('hidden');
        savedSelection = null;
      });

      // Link prefix buttons
      const linkPrefixBtns = linkPopup.querySelectorAll('.link-prefix-btn');
      const prefixPlaceholders = {
        'https://': 'www.example.com',
        'mailto:': 'name@example.com',
        'tel:': '+49 123 456789'
      };

      linkPrefixBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const prefix = btn.dataset.prefix;
          const currentValue = linkHrefInput.value;

          // Remove any existing prefix
          let cleanValue = currentValue
            .replace(/^https?:\/\//, '')
            .replace(/^mailto:/, '')
            .replace(/^tel:/, '');

          // Toggle: if same prefix was active, just clear it
          if (currentValue.startsWith(prefix)) {
            linkHrefInput.value = cleanValue;
            linkHrefInput.placeholder = '/path or #anchor';
            linkPrefixBtns.forEach(b => b.classList.remove('active'));
          } else {
            linkHrefInput.value = prefix + cleanValue;
            linkHrefInput.placeholder = prefixPlaceholders[prefix];
            linkPrefixBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
          }

          linkHrefInput.focus();
        });
      });

      // ============ ADD BLOCK ============

      addBlockBtn.addEventListener('click', () => {
        addBlockDropdown.classList.toggle('hidden');
      });

      addBlockDropdown.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const type = btn.dataset.type;
        const level = btn.dataset.level;
        const listType = btn.dataset.listType;
        const block = createBlockElement(type, level, '', listType);
        blockEditor.appendChild(block);
        // Focus on first editable element
        const focusTarget = block.querySelector('li[contenteditable="true"]') || block.querySelector('.block-content');
        if (focusTarget) focusTarget.focus();
        addBlockDropdown.classList.add('hidden');
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.block-actions-row')) {
          addBlockDropdown.classList.add('hidden');
        }
        if (!e.target.closest('.nav-link-popup') && !e.target.closest('#add-nav-link') && !e.target.closest('.nav-chip')) {
          navLinkPopup.classList.add('hidden');
        }
      });

      // ============ BUILD INPUT ============

      function parseInlineNodes(element) {
        const nodes = [];

        function processNodeInto(node, targetArray) {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            if (text) {
              targetArray.push({ type: 'text', text });
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            const children = [];
            for (const child of node.childNodes) {
              processNodeInto(child, children);
            }

            if (tag === 'br') {
              targetArray.push({ type: 'linebreak' });
            } else if (tag === 'b' || tag === 'strong') {
              targetArray.push({ type: 'bold', children });
            } else if (tag === 'i' || tag === 'em') {
              targetArray.push({ type: 'italic', children });
            } else if (tag === 'u') {
              targetArray.push({ type: 'underline', children });
            } else if (tag === 's' || tag === 'strike') {
              targetArray.push({ type: 'strikethrough', children });
            } else if (tag === 'code') {
              targetArray.push({ type: 'code', children });
            } else if (tag === 'a') {
              const href = node.getAttribute('href') || '';
              // Only include link if href is valid (same pattern as compiler)
              const hrefPattern = /^(\/[a-z0-9._/-]*|#[a-z0-9-]*|[a-z0-9-]+\.html|https?:\/\/[^\s]+|mailto:[^\s]+|tel:[^\s]+)$/i;
              if (href && hrefPattern.test(href)) {
                targetArray.push({ type: 'link', href, children });
              } else {
                // Invalid or empty href - just include children without link
                targetArray.push(...children);
              }
            } else {
              targetArray.push(...children);
            }
          }
        }

        for (const child of element.childNodes) {
          processNodeInto(child, nodes);
        }

        if (nodes.length === 0) {
          nodes.push({ type: 'text', text: '' });
        }

        return nodes;
      }

      function getContentFromBlocks() {
        const blocks = blockEditor.querySelectorAll('.block-item');
        const content = [];

        for (const block of blocks) {
          const type = block.dataset.type;

          if (type === 'bloglist') {
            // Bloglist options are configured globally in Settings â†’ Bloglist
            // Just store the block type, options will be applied from settings during compile
            content.push({ type: 'bloglist' });
          } else if (type === 'divider') {
            content.push({
              type: 'divider'
            });
          } else if (type === 'codeblock') {
            const contentEl = block.querySelector('.block-content');
            content.push({
              type: 'codeblock',
              content: contentEl.textContent || ''
            });
          } else if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
            const listEl = block.querySelector('.editable-list');
            const items = [];
            for (const li of listEl.querySelectorAll('li')) {
              items.push({
                children: parseInlineNodes(li)
              });
            }
            // Convert to compiler format: unordered-list or ordered-list
            const listType = block.dataset.listType || (type === 'ordered-list' ? 'ordered' : 'unordered');
            content.push({
              type: listType === 'ordered' ? 'ordered-list' : 'unordered-list',
              items
            });
          } else {
            const contentEl = block.querySelector('.block-content');
            const children = parseInlineNodes(contentEl);

            if (type === 'heading') {
              content.push({
                type: 'heading',
                level: parseInt(block.dataset.level, 10),
                children
              });
            } else if (type === 'blockquote') {
              content.push({
                type: 'blockquote',
                children
              });
            } else {
              content.push({
                type: 'paragraph',
                children
              });
            }
          }
        }

        return content;
      }

      function getNavigationItems() {
        const chips = navLinks.querySelectorAll('.nav-chip');
        return Array.from(chips).map(chip => ({
          text: chip.textContent,
          href: chip.dataset.href
        }));
      }


      async function buildInput(allowPagination = false) {
        const content = getContentFromBlocks();

        // For preview with empty content, use minimal placeholder
        const finalContent = content.length > 0
          ? content
          : [{ type: 'paragraph', children: [{ type: 'text', text: '' }] }];

        // Load posts if bloglist block is present
        let posts = [];
        const hasBloglist = finalContent.some(block => block.type === 'bloglist');
        if (hasBloglist) {
          try {
            posts = await App.getPosts();
          } catch (err) {
            console.warn('Failed to load posts for bloglist:', err);
          }
        }

        let navigation = null;
        if (navEnabled.checked) {
          const items = getNavigationItems();
          if (items.length > 0) {
            navigation = { items };
          }
        }

        let footer = null;
        if (footerEnabled.checked && footerText.value.trim()) {
          footer = { content: footerText.value.trim() };
        }

        let css = null;
        if (cssEnabled.checked && cssRules.value.trim()) {
          css = { rules: cssRules.value.trim() };
        }

        let meta = null;
        if (metaEnabled.checked) {
          const description = metaDescription.value.trim();
          const author = metaAuthor.value.trim();
          if (description || author) {
            meta = {};
            if (description) meta.description = description;
            if (author) meta.author = author;
          }
        }

        // Title override
        let titleOverride = null;
        if (titleOverrideEnabled.checked && titleOverrideInput.value.trim()) {
          titleOverride = titleOverrideInput.value.trim();
        }

        return {
          slug: slugInput.value.trim() || 'untitled',
          title: titleInput.value.trim() || 'Untitled',
          siteTitle: (window.globalConfig?.siteTitleEnabled !== false) ? (window.globalConfig?.siteTitle || null) : null,
          titleOverride,
          content: finalContent,
          navigation,
          footer,
          css,
          meta,
          icons: [],
          posts,
          allowPagination,
          buildId: crypto.randomUUID(),
          pageType: pageTypeSelect.value,
        };
      }

      // ============ BYTE COUNTER & COST RAIL ============

      function formatBytes(bytes) {
        return bytes.toLocaleString('de-DE') + ' B';
      }

      function updateByteCounter(totalBytes, overheadBytes = 0, contentBytes = null, breakdown = null) {
        const limit = 14336;
        const actualContentBytes = contentBytes !== null ? contentBytes : Math.max(0, totalBytes - overheadBytes);
        const overheadPercent = Math.min((overheadBytes / limit) * 100, 100);
        const totalPercent = Math.min((totalBytes / limit) * 100, 100);

        // Update Build Summary breakdown
        if (breakdown) {
          breakdownBase.textContent = formatBytes(breakdown.base);
          breakdownTitle.textContent = formatBytes(breakdown.title || 0);
          breakdownFavicon.textContent = formatBytes(breakdown.favicon || 0);
          breakdownNav.textContent = formatBytes(breakdown.navigation);
          breakdownMeta.textContent = formatBytes(breakdown.meta || 0);
          breakdownFooter.textContent = formatBytes(breakdown.footer);
          breakdownCss.textContent = formatBytes(breakdown.css);
          breakdownContent.textContent = formatBytes(breakdown.content);
          breakdownTotal.textContent = `${formatBytes(totalBytes)} / 14.336 B`;

          // Update rail indicators
          navBytesEl.textContent = formatBytes(breakdown.navigation);
          metaBytesEl.textContent = formatBytes(breakdown.meta || 0);
          footerBytesEl.textContent = formatBytes(breakdown.footer);
          cssBytesEl.textContent = formatBytes(breakdown.css);
        }

        // Update Cost Rail content total
        costContentTotal.textContent = formatBytes(actualContentBytes);

        // Calculate angles for pie chart (360 degrees = 100%)
        const overheadDeg = (overheadPercent / 100) * 360;
        const totalDeg = (totalPercent / 100) * 360;

        // Determine content color based on usage
        let contentColor = 'var(--accent)';
        pieContentDot.classList.remove('warning', 'danger');
        if (totalPercent >= 100) {
          contentColor = '#dc2626';
          pieContentDot.classList.add('danger');
        } else if (totalPercent >= 80) {
          contentColor = '#f59e0b';
          pieContentDot.classList.add('warning');
        }

        // Update pie chart with conic-gradient
        pieChart.style.background = `conic-gradient(
          var(--gray-400) 0deg ${overheadDeg}deg,
          ${contentColor} ${overheadDeg}deg ${totalDeg}deg,
          var(--gray-200) ${totalDeg}deg 360deg
        )`;

        // Update percentage in center
        piePercent.textContent = `${Math.round(totalPercent)}%`;
      }

      function updateCostRail() {
        const blocks = blockEditor.querySelectorAll('.block-item');
        let totalContentBytes = 0;

        blocks.forEach((block, index) => {
          const content = block.querySelector('.block-content');
          const byteIndicator = block.querySelector('.block-byte-indicator');
          const type = block.dataset.type;
          const level = block.dataset.level;
          const text = content ? content.textContent.trim() : '';

          // Rough byte estimation (real calculation happens server-side)
          const bytes = new TextEncoder().encode(text).length + 50; // +50 for markup
          totalContentBytes += bytes;

          // Determine semantic label
          let label = 'Paragraph';
          const listType = block.dataset.listType;
          if (type === 'heading') {
            label = `H${level}`;
          } else if (type === 'bloglist') {
            label = 'Bloglist';
          } else if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
            // Handle both old format (unordered-list/ordered-list) and new format (list + listType)
            if (listType === 'ordered' || type === 'ordered-list') {
              label = 'OL';
            } else {
              label = 'UL';
            }
          } else if (type === 'blockquote') {
            label = 'Quote';
          } else if (type === 'codeblock') {
            label = 'Code';
          } else if (type === 'divider') {
            label = 'HR';
          }

          // Update inline byte indicator
          if (byteIndicator) {
            byteIndicator.innerHTML = `<span>${label}</span><span>${formatBytes(bytes)}</span>`;
          }
        });

        // Update content total
        costContentTotal.textContent = formatBytes(totalContentBytes);
      }

      function updateTitleBytes() {
        const pageTitle = titleInput.value.trim() || 'Untitled';
        const titleOverrideValue = titleOverrideInput.value.trim();
        const siteTitleEnabled = window.globalConfig?.siteTitleEnabled !== false;
        const siteTitleText = window.globalConfig?.siteTitle;

        // Page Title: just the title input value
        const pageTitleBytes = new TextEncoder().encode(pageTitle).length;
        titleBytesEl.textContent = formatBytes(pageTitleBytes);

        // Browser Title: final <title> tag content
        let browserTitle;
        if (titleOverrideEnabled.checked && titleOverrideValue) {
          browserTitle = titleOverrideValue;
        } else if (siteTitleEnabled && siteTitleText) {
          browserTitle = `${pageTitle} | ${siteTitleText}`;
        } else {
          browserTitle = pageTitle;
        }

        // <title>TITEL</title> = 15 bytes markup + title bytes
        const browserTitleBytes = new TextEncoder().encode(browserTitle).length + 15;
        browserTitleBytesEl.textContent = formatBytes(browserTitleBytes);
      }

      // ============ MODAL SYSTEM ============

      const Modal = (() => {
        const backdrop = document.getElementById('modal-backdrop');
        const modal = document.getElementById('modal');
        const message = document.getElementById('modal-message');
        const actions = document.getElementById('modal-actions');

        function hide() {
          modal.classList.add('hidden');
          backdrop.classList.add('hidden');
          modal.className = 'modal hidden';
          actions.innerHTML = '';
        }

        function show(text, buttons, type = '', html = false) {
          if (html) {
            message.innerHTML = text;
          } else {
            message.textContent = text;
          }
          actions.innerHTML = '';
          modal.className = 'modal' + (type ? ` modal-${type}` : '');

          buttons.forEach(btn => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = btn.text;
            button.className = btn.class || '';
            button.addEventListener('click', () => {
              hide();
              if (btn.action) btn.action();
            });
            actions.appendChild(button);
          });

          backdrop.classList.remove('hidden');
          modal.classList.remove('hidden');
        }

        return {
          confirm(text) {
            return new Promise(resolve => {
              show(text, [
                { text: 'Yes', class: 'btn-primary', action: () => resolve(true) },
                { text: 'Cancel', class: 'btn-secondary', action: () => resolve(false) }
              ]);
            });
          },

          success(text, buttons = null, html = false) {
            show(text, buttons || [{ text: 'OK', class: 'btn-primary' }], 'success', html);
          },

          error(text, html = false) {
            show(text, [{ text: 'OK', class: 'btn-primary' }], 'error', html);
          },

          info(text) {
            show(text, [{ text: 'OK', class: 'btn-primary' }]);
          },

          hide
        };
      })();

      // Export Modal for inline handlers
      window.Modal = Modal;

      // ============ PUBLISH ============

      publishBtn.addEventListener('click', async () => {
        // Validate content before publish
        const blocks = blockEditor.querySelectorAll('.block-item');
        if (blocks.length === 0) {
          Modal.error(t('editor.buildError', { error: t('editor.blockRequired') }));
          return;
        }

        const confirmed = await Modal.confirm(t('editor.buildConfirm'));
        if (!confirmed) return;

        publishBtn.disabled = true;

        try {
          // First, check if pagination would be needed
          // Use App.preview() to include global settings (navigation, footer, CSS, etc.)
          const inputPreview = await buildInput(false);

          let shouldPaginate = false;

          // Try compiling without pagination first (with global settings applied)
          const previewResult = await App.preview(inputPreview);

          // Check if size limit exceeded (App.preview returns exceeded: true instead of throwing)
          if (previewResult.exceeded) {
            // Post is too large, try with pagination
            const inputWithPagination = await buildInput(true);
            const paginatedResult = await App.preview(inputWithPagination);

            if (!paginatedResult.exceeded && paginatedResult.measurements && paginatedResult.measurements.length > 1) {
              const estimatedPageCount = paginatedResult.measurements.length;

              // Ask user if they want to split
              const splitConfirmed = await Modal.confirm(
                t('editor.splitConfirm', { bytes: previewResult.bytes, pages: estimatedPageCount })
              );

              if (splitConfirmed) {
                shouldPaginate = true;
              } else {
                // User declined, abort publish
                Modal.error(t('editor.tooLarge'));
                publishBtn.disabled = false;
                return;
              }
            } else {
              // Can't be paginated
              Modal.error(t('editor.cannotSplit'));
              publishBtn.disabled = false;
              return;
            }
          } else if (previewResult.bytes > 14336) {
            // Compiled successfully but over 14KB - offer to split
            const inputWithPagination = await buildInput(true);
            const paginatedResult = await App.preview(inputWithPagination);

            if (!paginatedResult.exceeded && paginatedResult.measurements && paginatedResult.measurements.length > 1) {
              const estimatedPageCount = paginatedResult.measurements.length;

              // Ask user if they want to split
              const splitConfirmed = await Modal.confirm(
                t('editor.splitConfirm', { bytes: previewResult.bytes, pages: estimatedPageCount })
              );

              if (splitConfirmed) {
                shouldPaginate = true;
              } else {
                // User declined, abort publish
                publishBtn.disabled = false;
                return;
              }
            }
          }

          // Now do the actual publish with the user's choice
          const input = await buildInput(shouldPaginate);
          const result = await App.publish(input);

          // If this is a post (not page), regenerate archive page silently
          if (input.pageType !== 'page') {
            try {
              await App.generateArchivePage();
            } catch (archiveErr) {
              console.warn('Archive page regeneration failed:', archiveErr);
              // Don't show error to user - archive regeneration is best-effort
            }
          }

          const sizeInfo = result.pageCount && result.pageCount > 1
            ? `${result.pageCount} pages, ${result.totalBytes} bytes`
            : `${result.bytes} bytes`;

          Modal.success(
            `<strong>${t('editor.buildSuccess')}</strong><br>/${result.slug} (${sizeInfo})`,
            [
              { text: t('modal.ok'), class: 'btn-secondary' },
              { text: t('dashboard.view'), class: 'btn-primary', action: () => window.open(`/${result.slug}`, '_blank') }
            ],
            true
          );

          // Clear all fields after publish
          titleInput.value = '';
          slugInput.value = '';
          blockEditor.innerHTML = '';

          // Add one empty paragraph block
          const emptyBlock = createBlockElement('paragraph');
          blockEditor.appendChild(emptyBlock);

          // Reset title override
          titleOverrideEnabled.checked = false;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
          titleOverrideInput.value = '';

          // Reset navigation
          navEnabled.checked = false;
          navEnabled.dispatchEvent(new Event('change'));
          loadGlobalNavigation();

          // Reset footer
          footerEnabled.checked = false;
          footerEnabled.dispatchEvent(new Event('change'));
          footerText.value = '';

          // Reset meta
          metaEnabled.checked = false;
          metaEnabled.dispatchEvent(new Event('change'));
          metaDescription.value = '';
          metaAuthor.value = '';

          // Reset CSS
          cssEnabled.checked = false;
          cssEnabled.dispatchEvent(new Event('change'));
          cssRules.value = '';
          liveCSS.textContent = '';

          // Reset page type
          pageTypeSelect.value = 'post';
          pageTypeHint.textContent = '';

          // Clear auto-save
          clearAutoSave();

          // Reset byte counter
          updateByteCounter(0, 0);
          updateCostRail();
          updateTitleBytes();

          // Re-enable publish button
          publishBtn.disabled = false;
          publishBtn.textContent = t('editor.buildPublish');
        } catch (err) {
          Modal.error(err.message);
          console.error(err);
          publishBtn.disabled = false;
        }
      });

      // ============ INIT ============

      // Load global values into fields
      loadGlobalNavigation();
      loadGlobalFooter();
      loadGlobalMeta();
      loadGlobalCSS();

      // Set initial disabled states (after loading global values)
      navEditor.classList.remove('hidden');
      addNavLinkBtn.disabled = true;

      // Apply disabled state to navigation chips
      const initialChips = navLinks.querySelectorAll('.nav-chip');
      initialChips.forEach(chip => {
        chip.style.pointerEvents = 'none';
        chip.style.opacity = '0.6';
      });

      footerEditor.classList.remove('hidden');
      footerText.disabled = true;
      insertBytesBtn.disabled = true;

      metaEditor.classList.remove('hidden');
      metaDescription.disabled = true;
      metaAuthor.disabled = true;

      // Title override - disabled by default
      titleOverrideInput.disabled = true;
      updateTitleOverrideHint();

      cssEditor.classList.remove('hidden');
      cssRules.disabled = true;

      function debounce(fn, delay) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      }

      // ============ SEED TEMPLATES ============

      const templateSelector = document.getElementById('template-selector');
      const templateSelectorContainer = document.getElementById('template-selector-container');

      async function loadSeedTemplates() {
        try {
          const seeds = await App.getSeeds();
          
          if (seeds && seeds.length > 0) {
            seeds.forEach(seed => {
              const option = document.createElement('option');
              option.value = seed.name;
              option.textContent = seed.label;
              templateSelector.appendChild(option);
            });
          }
        } catch (err) {
          console.error('Failed to load seed templates:', err);
        }
      }

      templateSelector.addEventListener('change', async function() {
        const seedName = this.value;
        if (!seedName) return;
        
        try {
          const { sourceData } = await App.clonePage(seedName, 'seed');
          loadFromSource(sourceData);
          
          // Update title
          const pageTitle = document.getElementById('page-title');
          const pageSubtitle = document.getElementById('page-subtitle');
          pageTitle.textContent = `New (from ${seedName.replace('-', ' ')})`;
          pageSubtitle.textContent = 'Set title and slug to create a new page';
          
          // Reset dropdown
          this.value = '';
        } catch (err) {
          Modal.error(t('editor.templatesError', { error: err.message }));
          this.value = '';
        }
      });

      // Load seed templates on page load (only in new mode)
      const urlParams = new URLSearchParams(window.location.search);
      const editSlug = urlParams.get('edit');
      const isCloning = urlParams.get('clone') === 'true';
      
      if (!editSlug && !isCloning) {
        loadSeedTemplates();
      } else {
        // Hide template selector in edit/clone mode
        templateSelectorContainer.style.display = 'none';
      }

      // Check for edit mode (recompile from source)


      if (editSlug) {
        // Edit mode: load from source
        try {
          const sourceData = await App.getSourceData(editSlug);
          if (sourceData) {
            isEditMode = true;
            editingSlug = editSlug;
            loadFromSource(sourceData);
            // Show edit mode banner
            showEditModeBanner();
          }
        } catch (err) {
          console.error('Failed to load source:', err);
          Modal.error(t('editor.loadSourceError', { error: err.message }));
        }
      } else if (isCloning) {
        // Clone mode: load from sessionStorage
        try {
          const clonedData = sessionStorage.getItem('clonedSource');
          if (clonedData) {
            const sourceData = JSON.parse(clonedData);
            loadFromSource(sourceData);
            sessionStorage.removeItem('clonedSource');
            // Show notification
            const pageTitle = document.getElementById('page-title');
            const pageSubtitle = document.getElementById('page-subtitle');
            pageTitle.textContent = 'New (Cloned)';
            pageSubtitle.textContent = 'Set title and slug to create a new page';
          }
        } catch (err) {
          console.error('Failed to load cloned source:', err);
        }
      } else {
        // New document mode: try to restore from auto-save
        loadFromLocalStorage();
      }

      // Show edit mode indicator in title
      function showEditModeBanner() {
        const pageTitle = document.getElementById('page-title');
        const pageSubtitle = document.getElementById('page-subtitle');
        pageTitle.innerHTML = `Recompile <span style="font-weight: 400; color: var(--text-secondary);">/ ${editingSlug}</span>`;
        pageSubtitle.textContent = 'Editing source Â· requires rebuild';
        pageSubtitle.style.display = 'block';
      }

      // ============ CLEAR ALL BUTTON ============

      document.getElementById('clear-all-btn').addEventListener('click', async () => {
        const confirmed = await Modal.confirm(t('editor.resetConfirm'));
        if (!confirmed) return;

        // Clear all fields
        titleInput.value = '';
        slugInput.value = '';
        blockEditor.innerHTML = '';

        // Add one empty paragraph block
        const emptyBlock = createBlockElement('paragraph');
        blockEditor.appendChild(emptyBlock);

        // Reset title override (disabled)
        titleOverrideEnabled.checked = false;
        titleOverrideEnabled.dispatchEvent(new Event('change'));
        titleOverrideInput.value = '';

        // Reset navigation to global (disabled)
        navEnabled.checked = false;
        navEnabled.dispatchEvent(new Event('change'));
        loadGlobalNavigation();

        // Reset footer to global (disabled)
        footerEnabled.checked = false;
        footerEnabled.dispatchEvent(new Event('change'));
        loadGlobalFooter();

        // Reset meta to global (disabled)
        metaEnabled.checked = false;
        metaEnabled.dispatchEvent(new Event('change'));
        loadGlobalMeta();

        // Reset CSS to global (disabled)
        cssEnabled.checked = false;
        cssEnabled.dispatchEvent(new Event('change'));
        loadGlobalCSS();

        // Reset page type
        pageTypeSelect.value = 'post';
        pageTypeHint.textContent = '';

        // Clear auto-save
        clearAutoSave();

        // Reset byte counter
        updateByteCounter(0, 0);
        updateCostRail();
        updateTitleBytes();
      });

      updateByteCounter(0, 0);
      updateCostRail();
      updateTitleBytes();

      // Auto-update byte counter on content changes
      const debouncedPreview = debounce(async () => {
        saveToLocalStorage(); // Safety backup to localStorage (works in both modes)
        try {
          const input = await buildInput();
          const result = await App.preview(input);
          updateByteCounter(result.bytes, result.overheadBytes || 0, result.contentBytes, result.breakdown);

          // Clear previous block warnings
          blockEditor.querySelectorAll('.block-item.block-too-large').forEach(el => {
            el.classList.remove('block-too-large');
          });

          // Check if a block is too large for pagination
          if (result.blockTooLarge) {
            const blocks = blockEditor.querySelectorAll('.block-item');
            const blockIndex = result.blockTooLarge.blockIndex;
            if (blocks[blockIndex]) {
              blocks[blockIndex].classList.add('block-too-large');
            }
          }
        } catch (e) {
          // Ignore preview errors during editing
        }
      }, 500);

      // Listen for content changes
      blockEditor.addEventListener('input', () => {
        debouncedPreview();
        updateCostRail();
      });
      titleInput.addEventListener('input', debouncedPreview);
      titleOverrideInput.addEventListener('input', debouncedPreview);
      titleOverrideEnabled.addEventListener('change', debouncedPreview);
      footerText.addEventListener('input', debouncedPreview);
      cssRules.addEventListener('input', debouncedPreview);
      metaDescription.addEventListener('input', debouncedPreview);
      metaAuthor.addEventListener('input', debouncedPreview);
      navEnabled.addEventListener('change', debouncedPreview);
      footerEnabled.addEventListener('change', debouncedPreview);
      metaEnabled.addEventListener('change', debouncedPreview);
      cssEnabled.addEventListener('change', debouncedPreview);

      // Update cost rail when blocks change
      const observer = new MutationObserver(() => {
        updateCostRail();
      });
      observer.observe(blockEditor, { childList: true });

      // Initial preview to get overhead
      debouncedPreview();

    })();
  </script>
</body>

</html>