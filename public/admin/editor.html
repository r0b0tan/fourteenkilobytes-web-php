<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor - fourteenkilobytes</title>
  <link rel="icon" type="image/png" sizes="32x32" href="/admin/favicon-32x32.png">
  <link rel="stylesheet" href="/admin/style.css">
  <link rel="stylesheet" href="/admin/sections.css">
  <script src="/admin/i18n.js"></script>
</head>

<body>
  <!-- Loading Overlay (shown until editor is loaded) -->
  <div id="loading-overlay" class="loading-overlay instant">
    <div class="loading-state">
      <div class="loading-spinner"></div>
      <span>Loading...</span>
    </div>
  </div>

  <!-- Use semantic header element for better document structure -->
  <header class="header">
    <div class="header-top">
      <!-- Logo with improved accessibility -->
      <div class="logo-container">
        <a href="/admin/index.html" class="logo" aria-label="14KB Dashboard">
          <!-- SVG uses currentColor to inherit accent from CSS -->
          <svg version="1.0" xmlns="http://www.w3.org/2000/svg" width="32" height="32"
            viewBox="0 0 191.000000 191.000000" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
            <g transform="translate(0.000000,191.000000) scale(0.100000,-0.100000)" fill="currentColor" stroke="none">
              <path d="M406 1889 c-175 -35 -325 -178 -371 -356 -21 -81 -22 -1071 -1 -1149
47 -176 194 -315 374 -353 61 -13 1058 -16 1066 -3 2 4 -22 29 -55 55 -67 54
-152 157 -220 265 -24 39 -46 71 -49 72 -3 0 -18 -21 -34 -46 -41 -65 -64 -78
-116 -64 -63 17 -74 3 -65 -82 5 -57 4 -69 -10 -74 -24 -10 -45 15 -45 54 0
34 -1 34 -19 18 -10 -9 -21 -31 -25 -47 -5 -26 -10 -30 -33 -27 -23 2 -29 8
-31 35 -3 27 1 35 22 44 26 12 40 35 30 50 -9 16 -22 10 -58 -27 -40 -41 -72
-40 -82 2 -8 31 5 46 54 59 49 14 52 37 7 54 -19 7 -40 9 -45 6 -29 -18 -54
47 -28 73 17 17 35 15 66 -8 15 -12 41 -22 57 -23 28 -2 30 0 27 28 -8 85 -7
89 12 93 24 5 46 -23 46 -58 0 -37 29 -60 75 -60 51 0 69 18 101 106 l27 74
-19 42 c-26 59 -98 111 -196 143 -68 23 -91 36 -129 75 -58 59 -82 121 -109
278 -33 194 -24 242 44 242 36 0 242 -68 310 -102 87 -43 125 -102 140 -218 9
-60 39 -108 79 -125 20 -8 76 -15 138 -16 57 -1 142 -8 188 -15 46 -8 87 -12
90 -9 9 10 1 84 -14 119 -8 20 -25 41 -37 47 -20 11 -25 8 -55 -27 -27 -33
-35 -37 -50 -28 -10 6 -19 22 -21 36 -2 20 5 30 33 47 45 26 37 45 -16 38 -44
-6 -75 18 -65 51 9 29 30 33 70 17 57 -24 63 -18 22 24 -40 41 -44 66 -13 85
24 15 49 -2 59 -41 4 -17 15 -36 23 -43 21 -18 31 12 17 56 -8 27 -7 37 5 49
36 37 68 5 59 -58 -5 -32 -3 -47 8 -56 11 -9 18 -6 35 16 40 54 41 54 62 42
28 -15 22 -60 -11 -76 -57 -28 -65 -87 -25 -201 28 -82 31 -131 10 -171 -16
-31 -33 -41 -71 -41 -14 0 -34 -5 -45 -11 -26 -13 -15 -27 61 -79 30 -21 91
-70 135 -109 44 -39 85 -71 92 -71 20 0 18 909 -2 1003 -15 73 -58 162 -106
221 -40 48 -135 112 -207 139 -55 21 -71 22 -587 23 -305 1 -551 -2 -579 -7z" />
            </g>
          </svg>
          <!-- Stacked wordmark for compact branding -->
          <span class="logo-text" aria-hidden="true">14<br>KB</span>
        </a>
      </div>
      <!-- Semantic nav with improved structure -->
      <nav class="header-nav" aria-label="Main navigation">
        <a href="/admin/index.html" class="nav-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />
            <polyline points="9 22 9 12 15 12 15 22" />
          </svg>
          <span data-i18n="nav.overview">Overview</span>
        </a>
        <a href="/admin/editor.html" class="nav-icon active" aria-current="page">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <line x1="12" y1="5" x2="12" y2="19" />
            <line x1="5" y1="12" x2="19" y2="12" />
          </svg>
          <span data-i18n="nav.new">New</span>
        </a>
        <a href="/admin/settings.html" class="nav-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" />
          </svg>
          <span data-i18n="nav.settings">Settings</span>
        </a>
        <a href="/" target="_blank" rel="noopener" class="nav-icon external-link">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
            <polyline points="15 3 21 3 21 9" />
            <line x1="10" y1="14" x2="21" y2="3" />
          </svg>
          <span data-i18n="nav.blog">Blog</span>
        </a>
        <!-- Visual separator before logout -->
        <span class="nav-separator" aria-hidden="true"></span>
        <a href="#" id="logout-btn" class="nav-icon logout-icon">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            aria-hidden="true">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4" />
            <polyline points="16 17 21 12 16 7" />
            <line x1="21" y1="12" x2="9" y2="12" />
          </svg>
          <span data-i18n="nav.logout">Logout</span>
        </a>
      </nav>
    </div>
    <div style="margin-top: 32px;">
      <div>
        <h1 id="page-title" class="page-title" style="margin: 0;" data-i18n="editor.new">New</h1>
        <p id="page-subtitle" class="page-subtitle" style="margin: 4px 0 0 0;">Creating source Â· not yet compiled</p>
      </div>
      <div style="display: flex; gap: 12px; align-items: center; justify-content: flex-end; margin-top: 16px;">
        <div id="template-selector-container" style="display: flex; gap: 12px; align-items: center;">
          <select id="template-selector" class="page-type-select">
            <option value="" data-i18n="editor.templatesSelect">Select template...</option>
          </select>
        </div>
        <button type="button" id="clear-all-btn" class="btn btn-danger"> <svg width="14" height="14" viewBox="0 0 24 24"
            fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="23 4 23 10 17 10"></polyline>
            <polyline points="1 20 1 14 7 14"></polyline>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
          </svg><span data-i18n="editor.resetBtn">Reset</span></button>
      </div>
    </div>
  </header>

  <!-- Card: Head -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title" data-i18n="editor.head">Head</h2>
    </div>
    <div class="card-body card-body-grid">
      <div class="base-data-row">
        <div class="form-group">
          <label for="title" data-i18n="editor.title">Title</label>
          <input type="text" id="title" data-i18n-placeholder="editor.titlePlaceholder" placeholder="My first post">
        </div>
        <div class="form-group">
          <label for="slug" data-i18n="editor.slug">Slug</label>
          <input type="text" id="slug" data-i18n-placeholder="editor.slugPlaceholder" placeholder="my-first-post">
        </div>
        <div class="form-group">
          <label for="page-type" data-i18n="editor.pageType">Page Type</label>
          <select id="page-type" class="page-type-select">
            <option value="post" data-i18n="editor.pageTypePost">Post</option>
            <option value="page" data-i18n="editor.pageTypePage">Page</option>
          </select>
          <span id="page-type-hint" class="text-small text-muted"></span>
        </div>
      </div>
      <div class="rail-item">
        <span data-i18n="editor.blogTitle">Blog Title</span>
        <span id="title-bytes">0 B</span>
      </div>

      <!-- Title Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="title-override-enabled">
            <span data-i18n="editor.browserTabTitle">Browser Tab Title</span>
          </label>
          <p id="title-override-hint" class="override-hint"><svg class="hint-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg> <span data-i18n="editor.browserTabTitleHint">Using title only</span></p>
        </div>
        <div id="title-override-editor" class="override-editor">
          <div class="form-group">
            <label for="title-override" data-i18n="editor.browserTabTitle">Browser Tab Title</label>
            <input type="text" id="title-override" maxlength="100" placeholder="Custom browser tab title..." disabled>
          </div>
        </div>
      </div>
      <div class="rail-item" id="title-rail-item">
        <span data-i18n="editor.browserTabTitle">Browser Tab Title</span>
        <span id="browser-title-bytes">0 B</span>
      </div>

      <!-- Meta-Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="meta-enabled">
            <span data-i18n="settings.meta">Meta</span>
          </label>
          <p id="meta-global-hint" class="override-hint" data-i18n="settings.metaHint">Global SEO tags</p>
        </div>
        <div id="meta-editor" class="override-editor hidden">
          <div class="meta-row">
            <div class="form-group">
              <label for="meta-description" data-i18n="settings.metaDescription">Description</label>
              <input type="text" id="meta-description" maxlength="160" data-i18n-placeholder="settings.metaDescriptionPlaceholder" placeholder="Page description...">
            </div>
            <div class="form-group">
              <label for="meta-author" data-i18n="settings.metaAuthor">Author</label>
              <input type="text" id="meta-author" maxlength="100" data-i18n-placeholder="settings.metaAuthorPlaceholder" placeholder="Author name">
            </div>
          </div>
        </div>
      </div>
      <div class="rail-item" id="meta-rail-item">
        <span data-i18n="settings.meta">Meta</span>
        <span id="meta-bytes">0 B</span>
      </div>

      <!-- Navigation-Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="nav-enabled">
            <span data-i18n="settings.navigation">Navigation</span>
          </label>
          <p id="nav-global-hint" class="override-hint" data-i18n="settings.navigationHint">Navigation links</p>
        </div>
        <div id="nav-editor" class="override-editor hidden">
          <p class="text-small text-muted mb-1" data-i18n="settings.navigationHint">Navigation links (appear on every page)</p>
          <div class="nav-editor-row">
            <div id="nav-links" class="nav-links"></div>
            <button type="button" id="add-nav-link" class="btn btn-secondary" data-i18n="settings.navigationAddLink">+ Link</button>
          </div>
        </div>
      </div>
      <div class="rail-item" id="nav-rail-item">
        <span data-i18n="settings.navigation">Navigation</span>
        <span id="nav-bytes">0 B</span>
      </div>
    </div>
  </div>

  <!-- Card: Body -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title" data-i18n="editor.body">Body</h2>
    </div>
    <div class="card-body card-body-grid">
      <div class="block-editor-wrapper">
        <div id="block-editor" class="block-editor"></div>
        <div class="block-actions-row">
          <button type="button" id="add-block-btn" class="btn btn-secondary" data-i18n="editor.addBlock">+ Add Block</button>
          <div id="add-block-dropdown" class="add-block-dropdown hidden">
            <button type="button" data-type="paragraph" data-i18n="editor.blockParagraph">Paragraph</button>
            <button type="button" data-type="heading" data-level="2" data-i18n="editor.blockHeading">Heading</button>
            <button type="button" data-type="list" data-list-type="unordered" data-i18n="editor.blockList">List</button>
            <button type="button" data-type="divider" data-i18n="editor.blockDivider">Divider</button>
            <button type="button" data-type="spacer" data-i18n="editor.blockSpacer">Spacer</button>
            <button type="button" data-type="bloglist" data-i18n="editor.blockBloglist">Bloglist</button>
            <button type="button" data-type="section" data-i18n="editor.blockSection">Section</button>
          </div>
        </div>
      </div>
      <div class="rail-item rail-item-total" id="content-rail">
        <span data-i18n="editor.body">Body</span>
        <span id="cost-content-total">0 B</span>
      </div>
    </div>
  </div>

  <!-- Card: Footer -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title" data-i18n="editor.footer">Footer</h2>
    </div>
    <div class="card-body card-body-grid">
      <!-- Footer-Override -->
      <div class="override-section override-section-first">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="footer-enabled">
            <span data-i18n="settings.footerSection">Footer</span>
          </label>
          <p id="footer-global-hint" class="override-hint" data-i18n="settings.footerHint">Footer text</p>
        </div>
        <div id="footer-editor" class="override-editor hidden">
          <div class="footer-editor-row">
            <input type="text" id="footer-text" placeholder="Â© 2024 My Blog">
            <button type="button" id="insert-bytes-btn" class="btn btn-secondary" data-i18n="settings.footerBytesBtn">{{bytes}}</button>
          </div>
        </div>
      </div>
      <div class="rail-item">
        <span data-i18n="settings.footerSection">Footer</span>
        <span id="footer-bytes">0 B</span>
      </div>

      <!-- CSS Override -->
      <div class="override-section">
        <div class="override-section-header">
          <label class="override-toggle">
            <input type="checkbox" id="css-enabled">
            <span data-i18n="tabs.css">CSS</span>
          </label>
          <p id="css-global-hint" class="override-hint"></p>
        </div>
        <div id="css-editor" class="override-editor">
          <p class="css-warning-hint" data-i18n="settings.cssCustomHint">Custom CSS rules (embedded in every page)</p>
          <textarea id="css-rules" rows="10" data-i18n-placeholder="settings.cssCustom" placeholder="/* Additional CSS */"></textarea>
        </div>
      </div>
      <div class="rail-item">
        <span data-i18n="tabs.css">CSS</span>
        <span id="css-bytes">0 B</span>
      </div>
    </div>
  </div>

  <!-- Link Edit Popup for Navigation -->
  <div id="nav-link-popup" class="nav-link-popup hidden">
    <div class="popup-content">
      <div class="form-group">
        <label data-i18n="linkPopup.text">Text</label>
        <input type="text" id="nav-link-text" data-i18n-placeholder="linkPopup.textPlaceholder" placeholder="Home">
      </div>
      <div class="form-group">
        <label data-i18n="linkPopup.target">Target</label>
        <input type="text" id="nav-link-href" data-i18n-placeholder="linkPopup.targetPlaceholder" placeholder="/">
      </div>
      <div class="popup-actions">
        <button type="button" id="nav-link-save" class="btn btn-primary" data-i18n="linkPopup.save">OK</button>
        <button type="button" id="nav-link-delete" class="btn btn-danger" data-i18n="linkPopup.delete">Delete</button>
        <button type="button" id="nav-link-cancel" class="btn btn-secondary" data-i18n="linkPopup.cancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Floating Format Toolbar (disabled - using inline buttons in block header)
  <div id="format-toolbar" class="format-toolbar hidden">
    <button type="button" data-cmd="bold" title="Bold"><b>B</b></button>
    <button type="button" data-cmd="italic" title="Italic"><i>I</i></button>
    <button type="button" data-cmd="underline" title="Underline"><u>U</u></button>
    <button type="button" data-cmd="strikethrough" title="Strikethrough"><s>S</s></button>
    <button type="button" data-cmd="code" title="Code"><code>&lt;&gt;</code></button>
    <button type="button" data-cmd="link" title="Link">ðŸ”—</button>
  </div>
  -->

  <!-- Link Popup for content -->
  <div id="link-popup" class="link-popup hidden">
    <div class="link-prefix-buttons">
      <button type="button" class="link-prefix-btn" data-prefix="https://" title="URL">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
      </button>
      <button type="button" class="link-prefix-btn" data-prefix="mailto:" title="E-Mail">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
      </button>
      <button type="button" class="link-prefix-btn" data-prefix="tel:" title="Telefon">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>
      </button>
    </div>
    <input type="text" id="link-href" placeholder="/path or #anchor">
    <button type="button" id="link-apply" class="btn btn-primary">OK</button>
    <button type="button" id="link-cancel" class="btn btn-secondary">Ã—</button>
  </div>

  <!-- Modal System -->
  <div id="modal-backdrop" class="modal-backdrop hidden"></div>
  <div id="modal" class="modal hidden">
    <div class="modal-content">
      <p id="modal-message"></p>
      <div id="modal-actions" class="popup-actions"></div>
    </div>
  </div>

  <!-- Card: Build -->
  <div class="editor-card">
    <div class="card-header">
      <h2 class="card-title">Build</h2>
    </div>
    <div class="card-body card-body-with-rail">
      <div class="card-content">
        <div class="breakdown-table">
          <div class="breakdown-row">
            <span>Base</span>
            <span id="breakdown-base">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Title</span>
            <span id="breakdown-title">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Favicon</span>
            <span id="breakdown-favicon">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Navigation</span>
            <span id="breakdown-nav">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Meta</span>
            <span id="breakdown-meta">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Footer</span>
            <span id="breakdown-footer">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>CSS</span>
            <span id="breakdown-css">0 B</span>
          </div>
          <div class="breakdown-row">
            <span>Content</span>
            <span id="breakdown-content">0 B</span>
          </div>
          <div class="breakdown-row breakdown-row-total">
            <span>Total</span>
            <span id="breakdown-total">0 B / 14.336 B</span>
          </div>
        </div>
      </div>
      <div class="card-rail build-rail">
        <div class="build-progress">
          <div class="pie-chart" id="pie-chart">
            <span class="pie-percent" id="pie-percent">0%</span>
          </div>
          <div class="pie-legend">
            <div class="pie-legend-item">
              <span class="pie-dot pie-dot-overhead"></span>
              <span>Overhead</span>
            </div>
            <div class="pie-legend-item">
              <span class="pie-dot pie-dot-content"></span>
              <span>Content</span>
            </div>
            <div class="pie-legend-item">
              <span class="pie-dot pie-dot-free"></span>
              <span>Free</span>
            </div>
          </div>
        </div>
        <button id="publish-btn" class="btn btn-primary build-publish-btn" data-i18n="editor.buildPublish">Compile & Publish</button>
      </div>
    </div>
  </div>

  <!-- Live CSS Container -->
  <style id="live-css"></style>

  <script type="module" src="/admin/app.js"></script>
  <script type="module">
    // Import compiler (browser bundle)
    import * as Compiler from './compiler.browser.js';

    // Declare early to avoid initialization order issues
    let debouncedPreview;

    (async function () {
      // Wait for i18n to be ready
      await i18nReady();

      // Check if setup is complete
      const status = await App.getSetupStatus();
      if (!status.setupComplete) {
        window.location.href = '/setup/';
        return;
      }

      // Check auth
      const config = await App.getConfig();
      if (config.authEnabled && !(await App.isLoggedIn())) {
        window.location.href = 'index.html';
        return;
      }

      // Load settings with global header/footer/CSS
      const settings = await App.getSettings();
      window.globalConfig = settings;

      // Hide loading overlay
      document.getElementById('loading-overlay')?.remove();

      // Logout handler
      document.getElementById('logout-btn').addEventListener('click', async (e) => {
        e.preventDefault();
        await App.logout();
        window.location.href = '/admin/login.html';
      });

      // Elements
      const pageTypeSelect = document.getElementById('page-type');
      const pageTypeHint = document.getElementById('page-type-hint');
      const titleInput = document.getElementById('title');
      const slugInput = document.getElementById('slug');
      const blockEditor = document.getElementById('block-editor');
      const addBlockBtn = document.getElementById('add-block-btn');
      const addBlockDropdown = document.getElementById('add-block-dropdown');
      const formatToolbar = document.getElementById('format-toolbar');
      const linkPopup = document.getElementById('link-popup');
      const linkHrefInput = document.getElementById('link-href');
      const linkApplyBtn = document.getElementById('link-apply');
      const linkCancelBtn = document.getElementById('link-cancel');
      const navEnabled = document.getElementById('nav-enabled');
      const navEditor = document.getElementById('nav-editor');
      const navGlobalHint = document.getElementById('nav-global-hint');
      const navLinks = document.getElementById('nav-links');
      const addNavLinkBtn = document.getElementById('add-nav-link');
      const navLinkPopup = document.getElementById('nav-link-popup');
      const navLinkText = document.getElementById('nav-link-text');
      const navLinkHref = document.getElementById('nav-link-href');
      const navLinkSave = document.getElementById('nav-link-save');
      const navLinkDelete = document.getElementById('nav-link-delete');
      const navLinkCancel = document.getElementById('nav-link-cancel');
      const footerEnabled = document.getElementById('footer-enabled');
      const footerEditor = document.getElementById('footer-editor');
      const footerGlobalHint = document.getElementById('footer-global-hint');
      const footerText = document.getElementById('footer-text');
      const titleOverrideEnabled = document.getElementById('title-override-enabled');
      const titleOverrideEditor = document.getElementById('title-override-editor');
      const titleOverrideHint = document.getElementById('title-override-hint');
      const titleOverrideInput = document.getElementById('title-override');
      const metaEnabled = document.getElementById('meta-enabled');
      const metaEditor = document.getElementById('meta-editor');
      const metaGlobalHint = document.getElementById('meta-global-hint');
      const metaDescription = document.getElementById('meta-description');
      const metaAuthor = document.getElementById('meta-author');
      const cssEnabled = document.getElementById('css-enabled');
      const cssEditor = document.getElementById('css-editor');
      const cssGlobalHint = document.getElementById('css-global-hint');
      const cssRules = document.getElementById('css-rules');
      const liveCSS = document.getElementById('live-css');
      const publishBtn = document.getElementById('publish-btn');

      // Byte display elements
      const costContentTotal = document.getElementById('cost-content-total');
      const contentRail = document.getElementById('content-rail');
      const titleBytesEl = document.getElementById('title-bytes');
      const browserTitleBytesEl = document.getElementById('browser-title-bytes');
      const navBytesEl = document.getElementById('nav-bytes');
      const metaBytesEl = document.getElementById('meta-bytes');
      const footerBytesEl = document.getElementById('footer-bytes');
      const cssBytesEl = document.getElementById('css-bytes');

      // Build Card elements
      const breakdownBase = document.getElementById('breakdown-base');
      const breakdownTitle = document.getElementById('breakdown-title');
      const breakdownFavicon = document.getElementById('breakdown-favicon');
      const breakdownNav = document.getElementById('breakdown-nav');
      const breakdownMeta = document.getElementById('breakdown-meta');
      const breakdownFooter = document.getElementById('breakdown-footer');
      const breakdownCss = document.getElementById('breakdown-css');
      const breakdownContent = document.getElementById('breakdown-content');
      const breakdownTotal = document.getElementById('breakdown-total');
      const pieChart = document.getElementById('pie-chart');
      const piePercent = document.getElementById('pie-percent');
      const pieContentDot = document.querySelector('.pie-dot-content');

      // State
      let savedSelection = null;
      let editingNavLink = null; // The chip element being edited

      // ============ AUTO-SAVE ============

      const AUTOSAVE_KEY = 'editor-autosave';

      // Get current context from URL
      function getCurrentContext() {
        const params = new URLSearchParams(window.location.search);
        const editSlug = params.get('edit');
        return editSlug ? { mode: 'edit', slug: editSlug } : { mode: 'new', slug: null };
      }

      function saveToLocalStorage() {
        const context = getCurrentContext();
        try {
          const title = titleInput.value;
          const slug = slugInput.value;
          const pageType = pageTypeSelect.value;
          const content = getContentFromBlocks();

          const data = {
            // Context for validation on restore
            context,
            // Editor state
            title,
            slug,
            pageType,
            blocks: [],
            titleOverrideEnabled: titleOverrideEnabled.checked,
            titleOverride: titleOverrideEnabled.checked ? titleOverrideInput.value : null,
            navEnabled: navEnabled.checked,
            navigation: navEnabled.checked ? getNavigationItems() : null,
            footerEnabled: footerEnabled.checked,
            footer: footerEnabled.checked ? footerText.value : null,
            metaEnabled: metaEnabled.checked,
            metaDescription: metaDescription.value,
            metaAuthor: metaAuthor.value,
            cssEnabled: cssEnabled.checked,
            css: cssEnabled.checked ? cssRules.value : null,
            source: {
              title,
              slug,
              pageType,
              content,
              titleOverride: titleOverrideEnabled.checked && titleOverrideInput.value.trim()
                ? { enabled: true, title: titleOverrideInput.value.trim() }
                : null,
              navigation: navEnabled.checked ? { items: getNavigationItems() } : null,
              footer: footerEnabled.checked ? { content: footerText.value } : null,
              meta: metaEnabled.checked ? {
                description: metaDescription.value,
                author: metaAuthor.value
              } : null,
              css: cssEnabled.checked ? { rules: cssRules.value } : null
            },
            timestamp: Date.now()
          };

          // Save blocks
          const blocks = blockEditor.querySelectorAll('.block-item');
          blocks.forEach(blockItem => {
            const type = blockItem.dataset.type;
            const level = blockItem.dataset.level || null;
            const content = blockItem.querySelector('.block-content');
            if (content) {
              data.blocks.push({
                type,
                level,
                html: content.innerHTML
              });
            }
          });

          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
        } catch (err) {
          console.warn('Failed to auto-save:', err);
        }
      }

      function loadFromLocalStorage() {
        try {
          const saved = localStorage.getItem(AUTOSAVE_KEY);
          if (!saved) return false;

          const data = JSON.parse(saved);
          const currentContext = getCurrentContext();

          // Only restore if context matches (same mode and slug)
          if (data.context?.mode !== currentContext.mode ||
              data.context?.slug !== currentContext.slug) {
            return false;
          }

          // Check if data is not too old (older than 7 days)
          const age = Date.now() - (data.timestamp || 0);
          if (age > 7 * 24 * 60 * 60 * 1000) {
            localStorage.removeItem(AUTOSAVE_KEY);
            return false;
          }

          // Preferred restore path (v2 autosave): compiler-like source snapshot with nested blocks
          if (data.source && Array.isArray(data.source.content)) {
            loadFromSource(data.source);
            updatePageTitleSlug();
            return true;
          }

          // Restore basic fields
          titleInput.value = data.title || '';
          slugInput.value = data.slug || '';
          pageTypeSelect.value = data.pageType || 'post';

          // Restore blocks
          if (data.blocks && data.blocks.length > 0) {
            blockEditor.innerHTML = '';
            data.blocks.forEach(block => {
              const level = block.level || null;
              const blockElement = createBlockElement(block.type, level, block.html || '');
              blockEditor.appendChild(blockElement);
            });
          }

          // Restore title override
          if (data.titleOverrideEnabled) {
            titleOverrideEnabled.checked = true;
            titleOverrideEnabled.dispatchEvent(new Event('change'));
            titleOverrideInput.value = data.titleOverride || '';
          }

          // Restore navigation
          if (data.navEnabled) {
            navEnabled.checked = true;
            navEnabled.dispatchEvent(new Event('change'));
            if (data.navigation && data.navigation.length > 0) {
              navLinks.innerHTML = '';
              data.navigation.forEach(link => {
                navLinks.appendChild(createNavChip(link.text, link.href));
              });
            }
          }

          // Restore footer
          if (data.footerEnabled) {
            footerEnabled.checked = true;
            footerEnabled.dispatchEvent(new Event('change'));
            footerText.value = data.footer || '';
          }

          // Restore meta
          if (data.metaEnabled) {
            metaEnabled.checked = true;
            metaEnabled.dispatchEvent(new Event('change'));
            metaDescription.value = data.metaDescription || '';
            metaAuthor.value = data.metaAuthor || '';
          }

          // Restore CSS
          if (data.cssEnabled) {
            cssEnabled.checked = true;
            cssEnabled.dispatchEvent(new Event('change'));
            cssRules.value = data.css || '';
          }

          // Update page title with restored slug (for new mode)
          updatePageTitleSlug();

          return true;
        } catch (err) {
          console.warn('Failed to restore auto-save:', err);
          return false;
        }
      }

      function clearAutoSave() {
        try {
          localStorage.removeItem(AUTOSAVE_KEY);
        } catch (err) {
          console.warn('Failed to clear auto-save:', err);
        }
      }

      // ============ EDIT MODE (Source Editing) ============

      let isEditMode = false;
      let editingSlug = null;

      // Update page title with current slug (for new mode)
      function updatePageTitleSlug() {
        if (isEditMode) return; // Don't update in edit mode
        const pageTitle = document.getElementById('page-title');
        const slug = slugInput.value.trim();
        if (slug) {
          pageTitle.innerHTML = `New <span style="font-weight: 400; color: var(--text-secondary);">/ ${slug}</span>`;
        } else {
          pageTitle.textContent = 'New';
        }
      }

      // Convert inline nodes (compiler format) to HTML for editor
      function inlineNodesToHtml(nodes) {
        if (!nodes || !Array.isArray(nodes)) return '';
        return nodes.map(node => {
          switch (node.type) {
            case 'text':
              // Escape HTML entities
              return node.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            case 'linebreak':
              return '<br>';
            case 'bold':
              return `<b>${inlineNodesToHtml(node.children)}</b>`;
            case 'italic':
              return `<i>${inlineNodesToHtml(node.children)}</i>`;
            case 'underline':
              return `<u>${inlineNodesToHtml(node.children)}</u>`;
            case 'strikethrough':
              return `<s>${inlineNodesToHtml(node.children)}</s>`;
            case 'code':
              return `<code>${inlineNodesToHtml(node.children)}</code>`;
            case 'link':
              return `<a href="${node.href}">${inlineNodesToHtml(node.children)}</a>`;
            default:
              return inlineNodesToHtml(node.children);
          }
        }).join('');
      }

      // SVG icons for alignment buttons (shared by createBlockElement and blockElFromSource)
      const alignSvgs = {
        left: '<svg width="14" height="14" viewBox="0 0 14 14"><line x1="1" y1="3" x2="13" y2="3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="1" y1="7" x2="9" y2="7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="1" y1="11" x2="11" y2="11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>',
        center: '<svg width="14" height="14" viewBox="0 0 14 14"><line x1="1" y1="3" x2="13" y2="3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="3" y1="7" x2="11" y2="7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="2" y1="11" x2="12" y2="11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>',
        right: '<svg width="14" height="14" viewBox="0 0 14 14"><line x1="1" y1="3" x2="13" y2="3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="5" y1="7" x2="13" y2="7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><line x1="3" y1="11" x2="13" y2="11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>'
      };

      function selectorFromSourceBlock(block) {
        if (typeof block?.selector === 'string') {
          return block.selector.trim();
        }
        if (typeof block?.id === 'string' && block.id.trim()) {
          return `#${block.id.trim()}`;
        }
        if (typeof block?.className === 'string' && block.className.trim()) {
          return block.className
            .trim()
            .split(/\s+/)
            .filter(Boolean)
            .map(cls => `.${cls}`)
            .join('');
        }
        return '';
      }

      function applySelectorToBlockElement(element, block) {
        if (!element) return element;
        const selector = selectorFromSourceBlock(block);
        element.dataset.selector = selector;
        const selectorInput = element.querySelector('.block-selector-input');
        if (selectorInput) {
          selectorInput.value = selector;
        }
        return element;
      }

      let blockElFromSource = null;

      // Load editor state from source JSON (compiler format)
      function loadFromSource(sourceData) {
        // Restore basic fields
        titleInput.value = sourceData.title || '';
        slugInput.value = sourceData.slug || '';
        pageTypeSelect.value = sourceData.pageType || 'post';

        // Helper to create a block element from source data
        blockElFromSource = function(block, depth = 0) {
          const isNested = depth > 0;
          if (block.type === 'bloglist') {
            return applySelectorToBlockElement(createBlockElement('bloglist', null, '', null, null, isNested), block);
          }
          if (block.type === 'divider') {
            return applySelectorToBlockElement(createBlockElement('divider', null, '', null, null, isNested), block);
          }
          if (block.type === 'spacer') {
            return applySelectorToBlockElement(createBlockElement('spacer', null, '', null, block.height || '1rem', isNested), block);
          }
          if (block.type === 'codeblock') {
            return applySelectorToBlockElement(createBlockElement('codeblock', null, block.content || '', null, null, isNested), block);
          }
          if (block.type === 'unordered-list' || block.type === 'ordered-list') {
            const listType = block.type === 'ordered-list' ? 'ordered' : 'unordered';
            const el = createBlockElement('list', null, '', listType, null, isNested);
            const listEl = el.querySelector('.editable-list');
            if (listEl && block.items) {
              listEl.innerHTML = '';
              block.items.forEach(item => {
                const li = document.createElement('li');
                li.contentEditable = 'true';
                li.innerHTML = inlineNodesToHtml(item.children);
                listEl.appendChild(li);
              });
              setupListKeyHandlers(listEl);
            }
            return applySelectorToBlockElement(el, block);
          }
          if (block.type === 'section') {
            const el = createBlockElement('section', null, '', null, null, isNested);
            // Set properties
            el.dataset.background = block.background || '#1a1a1a';
            el.dataset.color = block.color || '#ffffff';
            el.dataset.pattern = block.pattern || '';
            el.dataset.patternColor = block.patternColor || '#ffffff';
            el.dataset.patternOpacity = block.patternOpacity || '0.1';
            el.dataset.width = block.width || '';
            el.dataset.padding = block.padding || '';
            el.dataset.align = block.align || '';

            // Update UI controls
            const bgInput = el.querySelector('.section-controls input[type="color"]');
            if (bgInput) bgInput.value = block.background || '#1a1a1a';
            
            const colorInputs = el.querySelectorAll('.section-inner-wrapper input[type="color"]');
            // 0=background, 1=text, 2=pattern
            if (colorInputs[1]) colorInputs[1].value = block.color || '#ffffff';
            if (colorInputs[2]) colorInputs[2].value = block.patternColor || '#ffffff';

            const patternSelect = el.querySelector('.section-pattern-select');
            if (patternSelect) patternSelect.value = block.pattern || '';
            const sectionInnerWrapper = el.querySelector('.section-inner-wrapper');
            if (sectionInnerWrapper) sectionInnerWrapper.classList.toggle('has-pattern', !!block.pattern);
            
            const opacityInput = el.querySelector('.section-pattern-row input[type="range"]');
            if (opacityInput) opacityInput.value = block.patternOpacity || '0.1';
            const opacityNumber = el.querySelector('.section-opacity-input');
            if (opacityNumber) opacityNumber.value = block.patternOpacity || '0.1';

            const widthInput = el.querySelector('.section-width-input');
            if (widthInput) widthInput.value = block.width || '';

            const paddingInput = el.querySelector('.section-padding-input');
            if (paddingInput) paddingInput.value = block.padding || '';

            const alignSelect = el.querySelector('.section-align-select');
            if (alignSelect) alignSelect.value = block.align || '';

            // Update preview colors
            const preview = el.querySelector('.section-preview');
            if (preview) {
              preview.style.backgroundColor = block.background || '#ffffff';
              preview.style.color = block.color || '#000000';
              preview.style.textAlign = block.align || '';
              if (block.padding) preview.style.setProperty('--sp', block.padding);
              const pClass = Compiler.getPatternClass(block.pattern || '');
              preview.className = 'section-preview ' + pClass;
              
              // Set PC var
              const opacity = parseFloat(block.patternOpacity || '0.1');
              const hex = block.patternColor || '#ffffff';
              const r = parseInt(hex.substring(1,3), 16);
              const g = parseInt(hex.substring(3,5), 16);
              const b = parseInt(hex.substring(5,7), 16);
              preview.style.setProperty('--pc', `rgba(${r},${g},${b},${opacity})`);
            }
            // Load child blocks
            if (block.children && block.children.length > 0) {
              const sectionBlocks = el.querySelector('.section-blocks');
              block.children.forEach(child => {
                sectionBlocks.appendChild(blockElFromSource(child, depth + 1));
              });
            }
            return applySelectorToBlockElement(el, block);
          }
          if (block.type === 'layout') {
            const el = createBlockElement('layout', null, '', null, null, isNested);
            const cols = block.columns || 2;
            const rows = block.cells ? Math.ceil(block.cells.length / cols) : 2;
            
            el.dataset.columns = cols;
            el.dataset.rows = rows;

            // Get cell grid and populate
            const cellsGrid = el.querySelector('.layout-cells-grid');
            if (cellsGrid && block.cells && block.cells.length > 0) {
              // Clear existing cells (keep controls)
              cellsGrid.querySelectorAll(':scope > .layout-cell').forEach(c => c.remove());
              
              // Recreate cells from data
              block.cells.forEach(cellData => {
                const cellEl = document.createElement('div');
                cellEl.className = 'layout-cell';

                // Cell toolbar
                const toolbar = document.createElement('div');
                toolbar.className = 'layout-cell-toolbar';

                // Alignment buttons
                const alignGroup = document.createElement('div');
                alignGroup.className = 'layout-toolbar-group';
                ['left', 'center', 'right'].forEach(align => {
                  const abtn = document.createElement('button');
                  abtn.type = 'button';
                  abtn.className = 'layout-align-btn';
                  abtn.dataset.align = align;
                  abtn.innerHTML = alignSvgs[align];
                  abtn.title = 'Align ' + align;
                  if (cellData.textAlign === align) abtn.classList.add('active');
                  abtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    cellEl.dataset.textAlign = align;
                    cellEl.style.textAlign = align;
                    alignGroup.querySelectorAll('.layout-align-btn').forEach(b => b.classList.remove('active'));
                    abtn.classList.add('active');
                    debouncedPreview();
                  });
                  alignGroup.appendChild(abtn);
                });
                toolbar.appendChild(alignGroup);

                // Padding input
                const padGroup = document.createElement('label');
                padGroup.className = 'layout-toolbar-input';
                padGroup.innerHTML = '<span>P</span>';
                const padInput = document.createElement('input');
                padInput.type = 'text';
                padInput.placeholder = '0';
                padInput.title = 'Padding';
                if (cellData.padding) { padInput.value = cellData.padding; cellEl.dataset.padding = cellData.padding; }
                padInput.addEventListener('input', () => {
                  cellEl.dataset.padding = padInput.value.trim();
                  debouncedPreview();
                });
                padGroup.appendChild(padInput);
                toolbar.appendChild(padGroup);

                // Margin input
                const marGroup = document.createElement('label');
                marGroup.className = 'layout-toolbar-input';
                marGroup.innerHTML = '<span>M</span>';
                const marInput = document.createElement('input');
                marInput.type = 'text';
                marInput.placeholder = '0';
                marInput.title = 'Margin';
                if (cellData.margin) { marInput.value = cellData.margin; cellEl.dataset.margin = cellData.margin; }
                marInput.addEventListener('input', () => {
                  cellEl.dataset.margin = marInput.value.trim();
                  debouncedPreview();
                });
                marGroup.appendChild(marInput);
                toolbar.appendChild(marGroup);

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.type = 'button';
                delBtn.className = 'layout-toolbar-delete';
                delBtn.textContent = 'Ã—';
                delBtn.title = 'Delete block';
                delBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  const cb = cellEl.querySelector('.layout-cell-blocks');
                  cb.innerHTML = '';
                  debouncedPreview();
                });
                toolbar.appendChild(delBtn);

                cellEl.appendChild(toolbar);

                // Restore alignment
                if (cellData.textAlign) {
                  cellEl.dataset.textAlign = cellData.textAlign;
                  cellEl.style.textAlign = cellData.textAlign;
                }

                const cellBlocks = document.createElement('div');
                cellBlocks.className = 'layout-cell-blocks';
                if (cellData.children && cellData.children.length > 0) {
                  const child = cellData.children[0];
                  cellBlocks.appendChild(blockElFromSource(child, depth + 1));
                }
                cellEl.appendChild(cellBlocks);

                // Add block button with type picker
                const addBtn = document.createElement('button');
                addBtn.type = 'button';
                addBtn.className = 'layout-cell-add-btn';
                addBtn.textContent = '+';
                addBtn.title = 'Add block';

                const dropdown = document.createElement('div');
                dropdown.className = 'layout-cell-dropdown hidden';
                const innerTypes = [
                  { type: 'paragraph', label: 'Paragraph' },
                  { type: 'heading', label: 'Heading', level: '2' },
                  { type: 'list', label: 'List', listType: 'unordered' },
                  { type: 'divider', label: 'Divider' },
                  { type: 'spacer', label: 'Spacer' }
                ];
                innerTypes.forEach(t => {
                  const b = document.createElement('button');
                  b.type = 'button';
                  b.textContent = t.label;
                  b.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newBlock = createBlockElement(t.type, t.level, '', t.listType, t.spacerHeight, true);
                    cellBlocks.appendChild(newBlock);
                    dropdown.classList.add('hidden');
                    const focusTarget = newBlock.querySelector('li[contenteditable="true"]') || newBlock.querySelector('.block-content');
                    if (focusTarget) focusTarget.focus();
                    debouncedPreview();
                  });
                  dropdown.appendChild(b);
                });

                addBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  dropdown.classList.toggle('hidden');
                });
                document.addEventListener('click', () => dropdown.classList.add('hidden'));

                cellEl.appendChild(addBtn);
                cellEl.appendChild(dropdown);

                cellsGrid.appendChild(cellEl);
              });

              // Update grid styling
              cellsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
              cellsGrid.style.gridTemplateRows = `repeat(${rows}, auto)`;
            }

            return applySelectorToBlockElement(el, block);
          }
          if (block.type === 'heading') {
            return applySelectorToBlockElement(createBlockElement('heading', block.level, inlineNodesToHtml(block.children), null, null, isNested), block);
          }
          if (block.type === 'blockquote') {
            return applySelectorToBlockElement(createBlockElement('blockquote', null, inlineNodesToHtml(block.children), null, null, isNested), block);
          }
          // paragraph
          return applySelectorToBlockElement(createBlockElement('paragraph', null, inlineNodesToHtml(block.children), null, null, isNested), block);
        };

        // Restore blocks from content array
        blockEditor.innerHTML = '';
        if (sourceData.content && sourceData.content.length > 0) {
          sourceData.content.forEach(block => {
            blockEditor.appendChild(blockElFromSource(block));
          });
        } else {
          // Add empty paragraph if no content
          blockEditor.appendChild(createBlockElement('paragraph'));
        }

        // Restore title override
        if (sourceData.titleOverride && typeof sourceData.titleOverride === 'object' && sourceData.titleOverride.enabled) {
          titleOverrideEnabled.checked = true;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
          titleOverrideInput.value = sourceData.titleOverride.title || '';
        } else if (typeof sourceData.titleOverride === 'string' && sourceData.titleOverride) {
          // Legacy format - titleOverride is just a string
          titleOverrideEnabled.checked = true;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
          titleOverrideInput.value = sourceData.titleOverride;
        } else {
          titleOverrideEnabled.checked = false;
          titleOverrideEnabled.dispatchEvent(new Event('change'));
        }

        // Restore navigation
        if (sourceData.navigation && sourceData.navigation.items && sourceData.navigation.items.length > 0) {
          navEnabled.checked = true;
          navEnabled.dispatchEvent(new Event('change'));
          navLinks.innerHTML = '';
          sourceData.navigation.items.forEach(link => {
            navLinks.appendChild(createNavChip(link.text, link.href));
          });
        } else {
          navEnabled.checked = false;
          navEnabled.dispatchEvent(new Event('change'));
          loadGlobalNavigation();
        }

        // Restore footer
        if (sourceData.footer && sourceData.footer.content) {
          footerEnabled.checked = true;
          footerEnabled.dispatchEvent(new Event('change'));
          footerText.value = sourceData.footer.content;
        } else {
          footerEnabled.checked = false;
          footerEnabled.dispatchEvent(new Event('change'));
          loadGlobalFooter();
        }

        // Restore meta
        if (sourceData.meta) {
          metaEnabled.checked = true;
          metaEnabled.dispatchEvent(new Event('change'));
          metaDescription.value = sourceData.meta.description || '';
          metaAuthor.value = sourceData.meta.author || '';
        } else {
          metaEnabled.checked = false;
          metaEnabled.dispatchEvent(new Event('change'));
          loadGlobalMeta();
        }

        // Restore CSS
        if (sourceData.css && sourceData.css.rules) {
          cssEnabled.checked = true;
          cssEnabled.dispatchEvent(new Event('change'));
          cssRules.value = sourceData.css.rules;
        } else {
          cssEnabled.checked = false;
          cssEnabled.dispatchEvent(new Event('change'));
          loadGlobalCSS();
        }
      }

      // ============ PAGE TYPE ============

      pageTypeSelect.addEventListener('change', () => {
        const type = pageTypeSelect.value;
        if (type === 'page') {
          pageTypeHint.textContent = '(not in feed)';
        } else {
          pageTypeHint.textContent = '';
        }
      });

      // ============ NAVIGATION EDITOR ============

      // Load global navigation into disabled fields
      function loadGlobalNavigation() {
        navLinks.innerHTML = '';
        if (window.globalConfig?.header?.links) {
          window.globalConfig.header.links.forEach(link => {
            navLinks.appendChild(createNavChip(link.text, link.href));
          });
        }
      }

      navEnabled.addEventListener('change', () => {
        navGlobalHint.classList.toggle('hidden', navEnabled.checked);

        // Toggle disabled state
        const chips = navLinks.querySelectorAll('.nav-chip');
        chips.forEach(chip => {
          chip.style.pointerEvents = navEnabled.checked ? 'auto' : 'none';
          chip.style.opacity = navEnabled.checked ? '1' : '0.6';
        });
        addNavLinkBtn.disabled = !navEnabled.checked;
      });

      function createNavChip(text, href) {
        const chip = document.createElement('span');
        chip.className = 'nav-chip';
        chip.dataset.href = href;
        chip.textContent = text;
        chip.draggable = true;
        chip.addEventListener('click', () => editNavLink(chip));

        // Drag & Drop
        chip.addEventListener('dragstart', (e) => {
          chip.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
        });

        chip.addEventListener('dragend', () => {
          chip.classList.remove('dragging');
          navLinks.querySelectorAll('.nav-chip').forEach(c => c.classList.remove('drag-over'));
        });

        chip.addEventListener('dragover', (e) => {
          e.preventDefault();
          const dragging = navLinks.querySelector('.dragging');
          if (dragging && dragging !== chip) {
            chip.classList.add('drag-over');
          }
        });

        chip.addEventListener('dragleave', () => {
          chip.classList.remove('drag-over');
        });

        chip.addEventListener('drop', (e) => {
          e.preventDefault();
          const dragging = navLinks.querySelector('.dragging');
          if (dragging && dragging !== chip) {
            const allChips = [...navLinks.querySelectorAll('.nav-chip')];
            const dragIndex = allChips.indexOf(dragging);
            const dropIndex = allChips.indexOf(chip);
            if (dragIndex < dropIndex) {
              chip.after(dragging);
            } else {
              chip.before(dragging);
            }
          }
          chip.classList.remove('drag-over');
        });

        return chip;
      }

      function editNavLink(chip) {
        editingNavLink = chip;
        navLinkText.value = chip.textContent;
        navLinkHref.value = chip.dataset.href;
        navLinkDelete.classList.remove('hidden');
        navLinkPopup.classList.remove('hidden');
        navLinkText.focus();
      }

      addNavLinkBtn.addEventListener('click', () => {
        editingNavLink = null;
        navLinkText.value = '';
        navLinkHref.value = '';
        navLinkDelete.classList.add('hidden');
        navLinkPopup.classList.remove('hidden');
        navLinkText.focus();
      });

      navLinkSave.addEventListener('click', () => {
        const text = navLinkText.value.trim();
        const href = navLinkHref.value.trim();
        if (!text || !href) return;

        if (editingNavLink) {
          editingNavLink.textContent = text;
          editingNavLink.dataset.href = href;
        } else {
          navLinks.appendChild(createNavChip(text, href));
        }
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      navLinkDelete.addEventListener('click', () => {
        if (editingNavLink) {
          editingNavLink.remove();
        }
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      navLinkCancel.addEventListener('click', () => {
        navLinkPopup.classList.add('hidden');
        editingNavLink = null;
      });

      // ============ FOOTER EDITOR ============

      const insertBytesBtn = document.getElementById('insert-bytes-btn');

      // Load global footer into disabled field
      function loadGlobalFooter() {
        if (window.globalConfig?.footer?.content) {
          footerText.value = window.globalConfig.footer.content;
        }
      }

      footerEnabled.addEventListener('change', () => {
        footerGlobalHint.classList.toggle('hidden', footerEnabled.checked);
        footerText.disabled = !footerEnabled.checked;
        insertBytesBtn.disabled = !footerEnabled.checked;
      });

      // ============ META EDITOR ============

      // Load global meta into disabled fields
      function loadGlobalMeta() {
        if (window.globalConfig?.meta?.description) {
          metaDescription.value = window.globalConfig.meta.description;
        }
        if (window.globalConfig?.meta?.author) {
          metaAuthor.value = window.globalConfig.meta.author;
        }
      }

      metaEnabled.addEventListener('change', () => {
        metaGlobalHint.classList.toggle('hidden', metaEnabled.checked);
        metaDescription.disabled = !metaEnabled.checked;
        metaAuthor.disabled = !metaEnabled.checked;
      });

      // ============ TITLE OVERRIDE EDITOR ============

      const checkIcon = '<svg class="hint-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"/></svg>';

      // HTML escape function to prevent XSS
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function updateTitleOverrideHint() {
        const siteTitleEnabled = window.globalConfig?.siteTitleEnabled !== false;
        const siteTitleText = window.globalConfig?.siteTitle;
        if (siteTitleEnabled && siteTitleText) {
          const escapedTitle = escapeHtml(siteTitleText);
          titleOverrideHint.innerHTML = `${checkIcon} <span>${t('editor.browserTabTitleHintWithSite').replace('Site Title', escapedTitle)}</span>`;
        } else {
          titleOverrideHint.innerHTML = `${checkIcon} <span data-i18n="editor.browserTabTitleHint">${t('editor.browserTabTitleHint')}</span>`;
        }
      }

      titleOverrideEnabled.addEventListener('change', () => {
        titleOverrideHint.classList.toggle('hidden', titleOverrideEnabled.checked);
        titleOverrideInput.disabled = !titleOverrideEnabled.checked;
        updateTitleBytes();
      });

      titleOverrideInput.addEventListener('input', () => {
        updateTitleBytes();
      });

      insertBytesBtn.addEventListener('click', () => {
        const cursorPos = footerText.selectionStart;
        const textBefore = footerText.value.substring(0, cursorPos);
        const textAfter = footerText.value.substring(cursorPos);
        footerText.value = textBefore + '{{bytes}}' + textAfter;
        footerText.focus();
        footerText.setSelectionRange(cursorPos + 9, cursorPos + 9);
        debouncedPreview();
      });

      // ============ CSS EDITOR ============

      function getThemeDisplayName(cssMode) {
        const names = {
          'default': 'CMS Default Theme',
          'light': 'CMS Light Theme',
          'dark': 'CMS Dark Theme',
          'custom': 'Custom CSS'
        };
        return names[cssMode] || cssMode || 'CMS Default Theme';
      }

      // Don't load global CSS - this field is for ADDITIONAL CSS only
      function loadGlobalCSS() {
        // Leave empty - this textarea is for additional CSS only
        // Global CSS is already included in the base template

        // Update hint with theme name
        const themeName = getThemeDisplayName(window.globalConfig?.cssMode);
        cssGlobalHint.innerHTML = `${checkIcon} <span>${themeName} is used globally</span>`;
      }

      cssEnabled.addEventListener('change', () => {
        cssGlobalHint.classList.toggle('hidden', cssEnabled.checked);
        cssRules.disabled = !cssEnabled.checked;
      });

      // ============ LIVE CSS ============

      cssRules.addEventListener('input', () => {
        applyLiveCSS();
      });

      function applyLiveCSS() {
        const css = cssRules.value.trim();
        // Scope CSS to block-editor to avoid breaking admin UI
        // Simple approach: prefix all rules with .block-editor
        if (!css) {
          liveCSS.textContent = '';
          return;
        }

        // Basic scoping - wrap in .block-editor context
        // This won't handle all edge cases but works for simple rules
        try {
          const scopedCSS = css.replace(/([^{}]+)\{/g, (match, selector) => {
            const selectors = selector.split(',').map(s => {
              s = s.trim();
              if (s.startsWith('@') || s.startsWith('from') || s.startsWith('to') || /^\d+%$/.test(s)) {
                return s;
              }
              if (s === 'body' || s === 'html') {
                return '.block-editor';
              }
              return `.block-editor ${s}`;
            }).join(', ');
            return selectors + ' {';
          });
          liveCSS.textContent = scopedCSS;
        } catch (e) {
          // Invalid CSS, ignore
        }
      }

      // ============ AUTO-SLUG ============

      titleInput.addEventListener('input', () => {
        if (!slugInput.dataset.manual) {
          slugInput.value = App.slugify(titleInput.value);
          updatePageTitleSlug();
        }
        updateTitleBytes();
      });

      slugInput.addEventListener('input', () => {
        slugInput.dataset.manual = 'true';
        updatePageTitleSlug();
      });

      // ============ BLOCK EDITOR ============

      function setupListKeyHandlers(listEl) {
        listEl.addEventListener('keydown', (e) => {
          const li = e.target.closest('li');
          if (!li) return;

          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            const newLi = document.createElement('li');
            newLi.contentEditable = 'true';
            newLi.dataset.placeholder = 'List item...';
            li.after(newLi);
            newLi.focus();
            debouncedPreview();
          } else if (e.key === 'Backspace' && li.innerHTML === '' && listEl.children.length > 1) {
            e.preventDefault();
            const prevLi = li.previousElementSibling;
            li.remove();
            if (prevLi) {
              prevLi.focus();
              // Move cursor to end
              const range = document.createRange();
              const sel = window.getSelection();
              range.selectNodeContents(prevLi);
              range.collapse(false);
              sel.removeAllRanges();
              sel.addRange(range);
            }
            debouncedPreview();
          }
        });
      }

      // Helper: create inner add-block dropdown for sections (no nesting allowed)
      function createInnerAddBlock(sectionBlock) {
        const row = document.createElement('div');
        row.className = 'section-add-row';

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn btn-secondary section-add-block';
        btn.setAttribute('data-i18n', 'editor.sectionAddBlock');
        btn.textContent = '+ Add Block';

        const dropdown = document.createElement('div');
        dropdown.className = 'add-block-dropdown hidden';

        const innerTypes = [
          { type: 'paragraph', i18n: 'editor.blockParagraph', label: 'Paragraph' },
          { type: 'heading', i18n: 'editor.blockHeading', label: 'Heading', level: '2' },
          { type: 'list', i18n: 'editor.blockList', label: 'List', listType: 'unordered' },
          { type: 'divider', i18n: 'editor.blockDivider', label: 'Divider' },
          { type: 'spacer', i18n: 'editor.blockSpacer', label: 'Spacer' },
          { type: 'layout', i18n: 'editor.blockLayout', label: 'Layout' }
        ];

        innerTypes.forEach(t => {
          const b = document.createElement('button');
          b.type = 'button';
          b.textContent = t.label;
          b.setAttribute('data-i18n', t.i18n);
          b.dataset.type = t.type;
          if (t.level) b.dataset.level = t.level;
          if (t.listType) b.dataset.listType = t.listType;
          dropdown.appendChild(b);
        });

        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown.classList.toggle('hidden');
        });

        dropdown.addEventListener('click', (e) => {
          const clicked = e.target.closest('button');
          if (!clicked) return;
          const childBlock = createBlockElement(clicked.dataset.type, clicked.dataset.level, '', clicked.dataset.listType, clicked.dataset.spacerHeight, true);
          const sectionBlocks = sectionBlock.querySelector('.section-blocks');
          sectionBlocks.appendChild(childBlock);
          const focusTarget = childBlock.querySelector('li[contenteditable="true"]') || childBlock.querySelector('.block-content');
          if (focusTarget) focusTarget.focus();
          dropdown.classList.add('hidden');
          debouncedPreview();
        });

        document.addEventListener('click', (e) => {
          if (!e.target.closest('.section-add-row')) {
            dropdown.classList.add('hidden');
          }
        });

        row.appendChild(btn);
        row.appendChild(dropdown);
        return row;
      }

      function createBlockElement(type, level, initialHtml = '', listType = null, spacerHeight = null, isNested = false) {
        const block = document.createElement('div');
        block.className = 'block-item';
        block.dataset.type = type;
        block.dataset.selector = '';
        if (level) block.dataset.level = level;
        if (listType) block.dataset.listType = listType;
        if (type === 'spacer') block.dataset.height = spacerHeight || '1rem';

        function createBlockSelectorControl(currentBlock) {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'block-selector-input';
          input.placeholder = '.your-css-class';
          input.title = 'CSS selector';
          input.value = currentBlock.dataset.selector || '';
          input.addEventListener('input', () => {
            currentBlock.dataset.selector = input.value.trim();
            updateCostRail();
            debouncedPreview();
          });

          return input;
        }

        // Section block: completely different DOM structure
        if (type === 'section') {
          block.className = 'block-item block-section';
          block.dataset.background = '#1a1a1a';
          block.dataset.color = '#ffffff';
          block.dataset.pattern = '';
          block.dataset.width = '';
          block.dataset.padding = '';
          block.dataset.align = '';

          // Header with label and actions
          const header = document.createElement('div');
          header.className = 'block-header';

          const label = document.createElement('span');
          label.className = 'block-type-label';
          label.setAttribute('data-i18n', 'editor.blockSection');
          label.textContent = 'Section';
          header.appendChild(label);

          const actions = document.createElement('div');
          actions.className = 'block-item-actions';
          if (!isNested) actions.appendChild(createBlockSelectorControl(block));
          const upBtn = document.createElement('button');
          upBtn.type = 'button';
          upBtn.textContent = 'â†‘';
          upBtn.title = 'Move up';
          upBtn.addEventListener('click', () => moveBlock(block, -1));
          actions.appendChild(upBtn);
          const downBtn = document.createElement('button');
          downBtn.type = 'button';
          downBtn.textContent = 'â†“';
          downBtn.title = 'Move down';
          downBtn.addEventListener('click', () => moveBlock(block, 1));
          actions.appendChild(downBtn);
          const copyBtn = document.createElement('button');
          copyBtn.type = 'button';
          copyBtn.innerHTML = 'â§‰';
          copyBtn.title = 'Duplicate';
          copyBtn.addEventListener('click', () => {
            const data = serializeBlock(block);
            const clone = blockElFromSource(data);
            insertBlockDirectlyBelow(block, clone);
            debouncedPreview();
          });
          actions.appendChild(copyBtn);
          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.textContent = 'Ã—';
          deleteBtn.title = 'Delete';
          deleteBtn.addEventListener('click', () => { block.remove(); debouncedPreview(); });
          actions.appendChild(deleteBtn);
          header.appendChild(actions);
          block.appendChild(header);

          // Wrapper for content (controls + preview) to match other blocks like bloglist
          const contentWrapper = document.createElement('div');
          contentWrapper.className = 'section-inner-wrapper';
          block.appendChild(contentWrapper);

          // Controls row: color pickers + pattern selector
          const controls = document.createElement('div');
          controls.className = 'section-controls';
          
          const bgLabel = document.createElement('label');
          bgLabel.innerHTML = '<span data-i18n="editor.sectionBackground">Background</span>:';
          const bgInput = document.createElement('input');
          bgInput.type = 'color';
          bgInput.value = '#ffffff';
          bgInput.addEventListener('input', () => {
            block.dataset.background = bgInput.value;
            preview.style.backgroundColor = bgInput.value;
            updateCostRail();
            debouncedPreview();
          });
          bgLabel.appendChild(bgInput);
          controls.appendChild(bgLabel);

          const colorLabel = document.createElement('label');
          colorLabel.innerHTML = '<span data-i18n="editor.sectionTextColor">Text Color</span>:';
          const colorInput = document.createElement('input');
          colorInput.type = 'color';
          colorInput.value = '#000000';
          colorInput.addEventListener('input', () => {
            block.dataset.color = colorInput.value;
            preview.style.color = colorInput.value;
            updateCostRail();
            debouncedPreview();
          });
          colorLabel.appendChild(colorInput);
          controls.appendChild(colorLabel);

          // Section Width (moved to first row)
          const swLabel = document.createElement('label');
          swLabel.innerHTML = '<span data-i18n="editor.sectionWidth">Width</span>:';
          const swInput = document.createElement('input');
          swInput.type = 'text';
          swInput.className = 'section-width-input';
          swInput.placeholder = '100%';
          swInput.value = '';
          swInput.addEventListener('input', () => {
            block.dataset.width = swInput.value.trim();
            updateCostRail();
            debouncedPreview();
          });
          swLabel.appendChild(swInput);
          controls.appendChild(swLabel);

          // Section Padding
          const spLabel = document.createElement('label');
          spLabel.innerHTML = '<span data-i18n="editor.sectionPadding">Padding</span>:';
          const spInput = document.createElement('input');
          spInput.type = 'text';
          spInput.className = 'section-padding-input';
          spInput.placeholder = '3rem';
          spInput.value = '';
          spInput.addEventListener('input', () => {
            block.dataset.padding = spInput.value.trim();
            // Update preview style var
            preview.style.setProperty('--sp', spInput.value.trim());
            updateCostRail();
            debouncedPreview();
          });
          spLabel.appendChild(spInput);
          controls.appendChild(spLabel);

          // Section Align
          const alLabel = document.createElement('label');
          alLabel.innerHTML = '<span data-i18n="editor.sectionAlign">Align</span>:';
          const alSelect = document.createElement('select');
          alSelect.className = 'section-align-select';
          const alOptions = [
            { value: '', label: 'Default' },
            { value: 'left', label: 'Left' },
            { value: 'center', label: 'Center' },
            { value: 'right', label: 'Right' }
          ];
          alOptions.forEach(opt => {
            const o = document.createElement('option');
            o.value = opt.value;
            o.textContent = opt.label;
            alSelect.appendChild(o);
          });
          alSelect.addEventListener('change', () => {
             block.dataset.align = alSelect.value;
             preview.style.textAlign = alSelect.value;
             updateCostRail();
             debouncedPreview();
          });
          alLabel.appendChild(alSelect);
          controls.appendChild(alLabel);

          const patternLabel = document.createElement('label');
          patternLabel.innerHTML = '<span data-i18n="editor.sectionPattern">Pattern</span>:';
          const patternSelect = document.createElement('select');
          patternSelect.className = 'section-pattern-select';
          const patternOptions = [
            { value: '', i18n: 'editor.sectionPatternNone', label: 'No Pattern' },
            { value: 'dots', i18n: 'editor.sectionPatternDots', label: 'Dots' },
            { value: 'grid', i18n: 'editor.sectionPatternGrid', label: 'Grid' },
            { value: 'stripes', i18n: 'editor.sectionPatternStripes', label: 'Stripes' },
            { value: 'cross', i18n: 'editor.sectionPatternCross', label: 'Crosshatch' },
            { value: 'hexagons', i18n: 'editor.sectionPatternHexagons', label: 'Hexagons' }
          ];
          patternOptions.forEach(opt => {
            const o = document.createElement('option');
            o.value = opt.value;
            o.textContent = opt.label;
            o.setAttribute('data-i18n', opt.i18n);
            patternSelect.appendChild(o);
          });
          patternSelect.addEventListener('change', () => {
            block.dataset.pattern = patternSelect.value;
            const patternClass = Compiler.getPatternClass(patternSelect.value);
            preview.className = 'section-preview ' + patternClass;
            contentWrapper.classList.toggle('has-pattern', !!patternSelect.value);
            updateCostRail();
            debouncedPreview();
          });
          patternLabel.appendChild(patternSelect);
          controls.appendChild(patternLabel);

          // Pattern sub-options row
          const patternRow = document.createElement('div');
          patternRow.className = 'section-pattern-row section-pattern-opts';

          // Pattern Color
          const pcLabel = document.createElement('label');
          pcLabel.innerHTML = '<span data-i18n="editor.sectionPatternColor">Pattern Color</span>:';
          const pcInput = document.createElement('input');
          pcInput.type = 'color';
          pcInput.value = '#ffffff';
          pcInput.addEventListener('input', () => {
            block.dataset.patternColor = pcInput.value;
            // Update CSS var on preview
            const opacity = parseFloat(block.dataset.patternOpacity || '0.1');
            const hex = pcInput.value;
            const r = parseInt(hex.substring(1,3), 16);
            const g = parseInt(hex.substring(3,5), 16);
            const b = parseInt(hex.substring(5,7), 16);
            preview.style.setProperty('--pc', `rgba(${r},${g},${b},${opacity})`);
            updateCostRail();
            debouncedPreview();
          });
          pcLabel.appendChild(pcInput);
          patternRow.appendChild(pcLabel);

          // Pattern Opacity
          const poLabel = document.createElement('label');
          poLabel.innerHTML = '<span data-i18n="editor.sectionPatternOpacity">Opacity</span>:';
          const poInput = document.createElement('input');
          poInput.type = 'range';
          poInput.min = '0';
          poInput.max = '1';
          poInput.step = '0.05';
          poInput.value = '0.1';
          const poNumber = document.createElement('input');
          poNumber.type = 'number';
          poNumber.className = 'section-opacity-input';
          poNumber.min = '0';
          poNumber.max = '1';
          poNumber.step = '0.05';
          poNumber.value = '0.1';
          function updateOpacity(val) {
            block.dataset.patternOpacity = val;
            const opacity = parseFloat(val);
            const hex = block.dataset.patternColor || '#ffffff';
            const r = parseInt(hex.substring(1,3), 16);
            const g = parseInt(hex.substring(3,5), 16);
            const b = parseInt(hex.substring(5,7), 16);
            preview.style.setProperty('--pc', `rgba(${r},${g},${b},${opacity})`);
            updateCostRail();
            debouncedPreview();
          }
          poInput.addEventListener('input', () => { poNumber.value = poInput.value; updateOpacity(poInput.value); });
          poNumber.addEventListener('input', () => { poInput.value = poNumber.value; updateOpacity(poNumber.value); });
          poLabel.appendChild(poInput);
          poLabel.appendChild(poNumber);
          patternRow.appendChild(poLabel);

          contentWrapper.appendChild(controls);
          contentWrapper.appendChild(patternRow);

          // Preview area with section background
          const preview = document.createElement('div');
          preview.className = 'section-preview';
          preview.style.backgroundColor = '#ffffff';
          preview.style.color = '#000000';

          const sectionBlocks = document.createElement('div');
          sectionBlocks.className = 'section-blocks';
          preview.appendChild(sectionBlocks);

          // Inner add-block button
          preview.appendChild(createInnerAddBlock(block));

          contentWrapper.appendChild(preview);

          // Byte indicator
          const byteIndicator = document.createElement('div');
          byteIndicator.className = 'block-byte-indicator';
          byteIndicator.textContent = '0 B';
          block.appendChild(byteIndicator);

          return block;
        }

        // Layout block: Simple grid container with dashed lines
        if (type === 'layout') {
          block.className = 'block-item block-layout';
          block.dataset.columns = '2';
          block.dataset.rows = '2';

          // Header with label and actions
          const header = document.createElement('div');
          header.className = 'block-header';

          const label = document.createElement('span');
          label.className = 'block-type-label';
          label.setAttribute('data-i18n', 'editor.blockLayout');
          label.textContent = 'Layout';
          header.appendChild(label);

          const actions = document.createElement('div');
          actions.className = 'block-item-actions';
          if (!isNested) actions.appendChild(createBlockSelectorControl(block));
          const upBtn = document.createElement('button');
          upBtn.type = 'button';
          upBtn.textContent = 'â†‘';
          upBtn.title = 'Move up';
          upBtn.addEventListener('click', () => moveBlock(block, -1));
          actions.appendChild(upBtn);
          const downBtn = document.createElement('button');
          downBtn.type = 'button';
          downBtn.textContent = 'â†“';
          downBtn.title = 'Move down';
          downBtn.addEventListener('click', () => moveBlock(block, 1));
          actions.appendChild(downBtn);
          const copyBtn = document.createElement('button');
          copyBtn.type = 'button';
          copyBtn.innerHTML = 'â§‰';
          copyBtn.title = 'Duplicate';
          copyBtn.addEventListener('click', () => {
            const data = serializeBlock(block);
            const clone = blockElFromSource(data);
            insertBlockDirectlyBelow(block, clone);
            debouncedPreview();
          });
          actions.appendChild(copyBtn);
          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.textContent = 'Ã—';
          deleteBtn.title = 'Delete';
          deleteBtn.addEventListener('click', () => { block.remove(); debouncedPreview(); });
          actions.appendChild(deleteBtn);
          header.appendChild(actions);
          block.appendChild(header);

          // Cells grid (direct child, no wrapper needed - .layout-grid uses display:contents)
          const cellsGrid = document.createElement('div');
          cellsGrid.className = 'layout-cells-grid';

          // Column controls (absolutely positioned inside cellsGrid)
          const colControls = document.createElement('div');
          colControls.className = 'layout-col-controls';
          const colLabel = document.createElement('span');
          colLabel.className = 'layout-control-label';
          colLabel.textContent = 'Col';
          const removeColBtn = document.createElement('button');
          removeColBtn.type = 'button';
          removeColBtn.className = 'layout-control-btn';
          removeColBtn.textContent = 'âˆ’';
          removeColBtn.title = 'Remove column';
          removeColBtn.addEventListener('click', () => {
            const cols = parseInt(block.dataset.columns);
            if (cols > 1) {
              block.dataset.columns = cols - 1;
              rebuildGrid();
            }
          });
          const addColBtn = document.createElement('button');
          addColBtn.type = 'button';
          addColBtn.className = 'layout-control-btn';
          addColBtn.textContent = '+';
          addColBtn.title = 'Add column';
          addColBtn.addEventListener('click', () => {
            const cols = parseInt(block.dataset.columns);
            block.dataset.columns = Math.min(cols + 1, 6);
            rebuildGrid();
          });
          colControls.appendChild(removeColBtn);
          colControls.appendChild(colLabel);
          colControls.appendChild(addColBtn);
          cellsGrid.appendChild(colControls);

          // Row controls (absolutely positioned inside cellsGrid)
          const rowControls = document.createElement('div');
          rowControls.className = 'layout-row-controls';
          const rowLabel = document.createElement('span');
          rowLabel.className = 'layout-control-label';
          rowLabel.textContent = 'Row';
          const removeRowBtn = document.createElement('button');
          removeRowBtn.type = 'button';
          removeRowBtn.className = 'layout-control-btn';
          removeRowBtn.textContent = 'âˆ’';
          removeRowBtn.title = 'Remove row';
          removeRowBtn.addEventListener('click', () => {
            const rows = parseInt(block.dataset.rows);
            if (rows > 1) {
              block.dataset.rows = rows - 1;
              rebuildGrid();
            }
          });
          const addRowBtn = document.createElement('button');
          addRowBtn.type = 'button';
          addRowBtn.className = 'layout-control-btn';
          addRowBtn.textContent = '+';
          addRowBtn.title = 'Add row';
          addRowBtn.addEventListener('click', () => {
            const rows = parseInt(block.dataset.rows);
            block.dataset.rows = rows + 1;
            rebuildGrid();
          });
          rowControls.appendChild(removeRowBtn);
          rowControls.appendChild(rowLabel);
          rowControls.appendChild(addRowBtn);
          cellsGrid.appendChild(rowControls);

          block.appendChild(cellsGrid);

          // Rebuild grid based on rows/cols
          function rebuildGrid() {
            const cols = parseInt(block.dataset.columns);
            const rows = parseInt(block.dataset.rows);
            cellsGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            cellsGrid.style.gridTemplateRows = `repeat(${rows}, auto)`;

            const totalCells = cols * rows;
            const currentCells = cellsGrid.querySelectorAll(':scope > .layout-cell');

            // Remove excess cells
            if (currentCells.length > totalCells) {
              for (let i = totalCells; i < currentCells.length; i++) {
                currentCells[i].remove();
              }
            }

            // Add missing cells
            while (cellsGrid.querySelectorAll(':scope > .layout-cell').length < totalCells) {
              cellsGrid.appendChild(createLayoutCell());
            }

            updateCostRail();
            if (debouncedPreview) {
              debouncedPreview();
            }
          }

          // Create cell helper function
          function createLayoutCell() {
            const cell = document.createElement('div');
            cell.className = 'layout-cell';

            // Cell toolbar (alignment, padding, margin, delete)
            const toolbar = document.createElement('div');
            toolbar.className = 'layout-cell-toolbar';

            // Alignment buttons
            const alignGroup = document.createElement('div');
            alignGroup.className = 'layout-toolbar-group';
            ['left', 'center', 'right'].forEach(align => {
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'layout-align-btn';
              btn.dataset.align = align;
              btn.innerHTML = alignSvgs[align];
              btn.title = 'Align ' + align;
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                cell.dataset.textAlign = align;
                cell.style.textAlign = align;
                alignGroup.querySelectorAll('.layout-align-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (debouncedPreview) debouncedPreview();
              });
              alignGroup.appendChild(btn);
            });
            toolbar.appendChild(alignGroup);

            // Padding input
            const padGroup = document.createElement('label');
            padGroup.className = 'layout-toolbar-input';
            padGroup.innerHTML = '<span>P</span>';
            const padInput = document.createElement('input');
            padInput.type = 'text';
            padInput.placeholder = '0';
            padInput.title = 'Padding (z.B. 1rem, 8px)';
            padInput.addEventListener('input', () => {
              cell.dataset.padding = padInput.value.trim();
              if (debouncedPreview) debouncedPreview();
            });
            padGroup.appendChild(padInput);
            toolbar.appendChild(padGroup);

            // Margin input
            const marGroup = document.createElement('label');
            marGroup.className = 'layout-toolbar-input';
            marGroup.innerHTML = '<span>M</span>';
            const marInput = document.createElement('input');
            marInput.type = 'text';
            marInput.placeholder = '0';
            marInput.title = 'Margin (z.B. 1rem, 8px)';
            marInput.addEventListener('input', () => {
              cell.dataset.margin = marInput.value.trim();
              if (debouncedPreview) debouncedPreview();
            });
            marGroup.appendChild(marInput);
            toolbar.appendChild(marGroup);

            // Delete button
            const delBtn = document.createElement('button');
            delBtn.type = 'button';
            delBtn.className = 'layout-toolbar-delete';
            delBtn.textContent = 'Ã—';
            delBtn.title = 'Delete block';
            delBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              const cellBlocks = cell.querySelector('.layout-cell-blocks');
              cellBlocks.innerHTML = '';
              if (debouncedPreview) debouncedPreview();
            });
            toolbar.appendChild(delBtn);

            cell.appendChild(toolbar);

            const cellBlocks = document.createElement('div');
            cellBlocks.className = 'layout-cell-blocks';
            cell.appendChild(cellBlocks);

            // Add block button with type picker
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.className = 'layout-cell-add-btn';
            addBtn.textContent = '+';
            addBtn.title = 'Add block';

            const dropdown = document.createElement('div');
            dropdown.className = 'layout-cell-dropdown hidden';
            const innerTypes = [
              { type: 'paragraph', label: 'Paragraph' },
              { type: 'heading', label: 'Heading', level: '2' },
              { type: 'list', label: 'List', listType: 'unordered' },
              { type: 'divider', label: 'Divider' },
              { type: 'spacer', label: 'Spacer' }
            ];
            innerTypes.forEach(t => {
              const b = document.createElement('button');
              b.type = 'button';
              b.textContent = t.label;
              b.addEventListener('click', (e) => {
                e.stopPropagation();
                const childBlock = createBlockElement(t.type, t.level, '', t.listType, t.spacerHeight, true);
                cellBlocks.appendChild(childBlock);
                dropdown.classList.add('hidden');
                const focusTarget = childBlock.querySelector('li[contenteditable="true"]') || childBlock.querySelector('.block-content');
                if (focusTarget) focusTarget.focus();
                if (debouncedPreview) debouncedPreview();
              });
              dropdown.appendChild(b);
            });

            addBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              dropdown.classList.toggle('hidden');
            });
            document.addEventListener('click', () => dropdown.classList.add('hidden'));

            cell.appendChild(addBtn);
            cell.appendChild(dropdown);

            return cell;
          }

          // Create initial 2x2 grid
          rebuildGrid();

          // Byte indicator
          const byteIndicator = document.createElement('div');
          byteIndicator.className = 'block-byte-indicator';
          byteIndicator.textContent = '0 B';
          block.appendChild(byteIndicator);

          return block;
        }

        // Block header with type selector and actions
        const header = document.createElement('div');
        header.className = 'block-header';

        // Type selector
        if (type === 'paragraph' || type === 'blockquote' || type === 'codeblock') {
          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="paragraph">Paragraph</option>
            <option value="blockquote">Blockquote</option>
            <option value="codeblock">Code Block</option>
          `;
          typeSelect.value = type;
          typeSelect.addEventListener('change', () => {
            const newType = typeSelect.value;
            const oldType = block.dataset.type;
            block.dataset.type = newType;

            // Handle content conversion
            const content = block.querySelector('.block-content');
            if (oldType === 'codeblock' && newType !== 'codeblock') {
              // From codeblock to rich text - convert plain text
              content.contentEditable = 'true';
              content.classList.remove('block-codeblock');
              content.dataset.placeholder = newType === 'blockquote' ? 'Quote...' : 'Enter text...';
              // Show format buttons
              const formatBtns = block.querySelector('.block-format-buttons');
              if (formatBtns) formatBtns.style.display = '';
            } else if (oldType !== 'codeblock' && newType === 'codeblock') {
              // From rich text to codeblock - strip HTML
              content.textContent = content.textContent;
              content.contentEditable = 'true';
              content.classList.add('block-codeblock');
              content.dataset.placeholder = 'Code...';
              // Hide format buttons
              const formatBtns = block.querySelector('.block-format-buttons');
              if (formatBtns) formatBtns.style.display = 'none';
            } else {
              // Just update placeholder
              content.dataset.placeholder = newType === 'blockquote' ? 'Quote...' : newType === 'codeblock' ? 'Code...' : 'Enter text...';
            }

            updateBlockStyling(block);
            updateCostRail();
            debouncedPreview();
          });
          header.appendChild(typeSelect);
        } else if (type === 'heading') {
          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="1">H1</option>
            <option value="2">H2</option>
            <option value="3">H3</option>
            <option value="4">H4</option>
            <option value="5">H5</option>
            <option value="6">H6</option>
          `;
          typeSelect.value = level || '2';
          typeSelect.addEventListener('change', () => {
            block.dataset.level = typeSelect.value;
            updateBlockStyling(block);
            updateCostRail();
            debouncedPreview();
          });
          header.appendChild(typeSelect);
        } else if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
          // Normalize type for new blocks - use passed listType or derive from legacy type
          const effectiveListType = listType || (type === 'ordered-list' ? 'ordered' : 'unordered');
          block.dataset.type = 'list';
          block.dataset.listType = effectiveListType;

          const typeSelect = document.createElement('select');
          typeSelect.className = 'block-type-select';
          typeSelect.innerHTML = `
            <option value="unordered">Unordered List</option>
            <option value="ordered">Ordered List</option>
          `;
          typeSelect.value = effectiveListType;
          typeSelect.addEventListener('change', () => {
            const newListType = typeSelect.value;
            block.dataset.listType = newListType;
            // Update list element tag
            const oldList = block.querySelector('.editable-list');
            if (oldList) {
              const newTag = newListType === 'ordered' ? 'ol' : 'ul';
              const newList = document.createElement(newTag);
              newList.className = 'editable-list';
              // Move all children
              while (oldList.firstChild) {
                newList.appendChild(oldList.firstChild);
              }
              // Copy event listeners by replacing
              oldList.replaceWith(newList);
              setupListKeyHandlers(newList);
            }
            updateCostRail();
            debouncedPreview();
          });
          header.appendChild(typeSelect);
        } else {
          // Bloglist, Divider or Spacer - just a label
          const label = document.createElement('span');
          label.className = 'block-type-label';
          if (type === 'divider') {
            label.setAttribute('data-i18n', 'editor.blockDivider');
            label.textContent = 'Divider';
          } else if (type === 'spacer') {
            label.setAttribute('data-i18n', 'editor.blockSpacer');
            label.textContent = 'Spacer';
          } else {
            label.setAttribute('data-i18n', 'editor.blockBloglist');
            label.textContent = 'Bloglist';
          }
          header.appendChild(label);
        }

        // Format buttons (nur fÃ¼r rich-text BlÃ¶cke)
        if (type !== 'bloglist' && type !== 'divider' && type !== 'codeblock' && type !== 'spacer') {
          const formatBtns = document.createElement('div');
          formatBtns.className = 'block-format-buttons';

          const formats = [
            { cmd: 'bold', label: 'B', title: 'Bold', style: 'font-weight:bold' },
            { cmd: 'italic', label: 'I', title: 'Italic', style: 'font-style:italic' },
            { cmd: 'underline', label: 'U', title: 'Underline', style: 'text-decoration:underline' },
            { cmd: 'strikethrough', label: 'S', title: 'Strikethrough', style: 'text-decoration:line-through' },
            { cmd: 'code', label: '<>', title: 'Code', style: 'font-family:monospace;font-size:11px' },
            { cmd: 'link', label: 'ðŸ”—', title: 'Link', style: '' }
          ];

          formats.forEach(fmt => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.innerHTML = `<span style="${fmt.style}">${fmt.label}</span>`;
            btn.title = fmt.title;
            btn.dataset.cmd = fmt.cmd;
            btn.addEventListener('click', () => handleFormatClick(fmt.cmd, block));
            formatBtns.appendChild(btn);
          });

          header.appendChild(formatBtns);
        }

        const actions = document.createElement('div');
        actions.className = 'block-item-actions';
        if (!isNested) actions.appendChild(createBlockSelectorControl(block));

        const upBtn = document.createElement('button');
        upBtn.type = 'button';
        upBtn.textContent = 'â†‘';
        upBtn.title = 'Move up';
        upBtn.addEventListener('click', () => moveBlock(block, -1));
        actions.appendChild(upBtn);

        const downBtn = document.createElement('button');
        downBtn.type = 'button';
        downBtn.textContent = 'â†“';
        downBtn.title = 'Move down';
        downBtn.addEventListener('click', () => moveBlock(block, 1));
        actions.appendChild(downBtn);

        const copyBtn = document.createElement('button');
        copyBtn.type = 'button';
        copyBtn.innerHTML = 'â§‰';
        copyBtn.title = 'Duplicate';
        copyBtn.addEventListener('click', () => {
          const data = serializeBlock(block);
          const clone = blockElFromSource(data);
          insertBlockDirectlyBelow(block, clone);
          debouncedPreview();
        });
        actions.appendChild(copyBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'Delete';
        deleteBtn.addEventListener('click', () => block.remove());
        actions.appendChild(deleteBtn);

        header.appendChild(actions);

        // Byte indicator fÃ¼r diesen Block
        const byteIndicator = document.createElement('div');
        byteIndicator.className = 'block-byte-indicator';
        byteIndicator.textContent = '0 B';
        block.appendChild(byteIndicator);

        block.appendChild(header);

        // Content area
        const content = document.createElement('div');
        content.className = 'block-content';
        if (type === 'bloglist') {
          content.contentEditable = 'false';
          content.className = 'block-content block-bloglist';
          content.innerHTML = `
            <div class="bloglist-config">
              <div class="bloglist-info">
                <em style="color: #999;" data-i18n="editor.bloglistPlaceholder">Blog posts will be listed here automatically</em>
              </div>
              <div class="bloglist-settings-link">
                <a href="settings.html#bloglist" style="color: var(--text-secondary); font-size: 12px;" data-i18n="editor.bloglistSettingsLink">Configure in Settings â†’ Bloglist</a>
              </div>
            </div>
          `;
        } else if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
          content.className = 'block-content block-list';
          // Determine list tag from listType or legacy type
          const listType = block.dataset.listType || (type === 'ordered-list' ? 'ordered' : 'unordered');
          const listEl = document.createElement(listType === 'ordered' ? 'ol' : 'ul');
          listEl.className = 'editable-list';

          // Check if initialHtml contains a list (for restoring saved data)
          if (initialHtml && (initialHtml.includes('<li>') || initialHtml.includes('<li '))) {
            // Parse the saved HTML to extract list items
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = initialHtml;
            const existingList = tempDiv.querySelector('ul, ol');
            const existingItems = existingList ? existingList.querySelectorAll('li') : tempDiv.querySelectorAll('li');

            if (existingItems.length > 0) {
              existingItems.forEach(existingLi => {
                const li = document.createElement('li');
                li.contentEditable = 'true';
                li.dataset.placeholder = 'List item...';
                li.innerHTML = existingLi.innerHTML;
                listEl.appendChild(li);
              });
            } else {
              // Fallback: create empty item
              const li = document.createElement('li');
              li.contentEditable = 'true';
              li.dataset.placeholder = 'List item...';
              listEl.appendChild(li);
            }
          } else {
            // New list: create single empty item
            const li = document.createElement('li');
            li.contentEditable = 'true';
            li.dataset.placeholder = 'List item...';
            li.innerHTML = initialHtml || '';
            listEl.appendChild(li);
          }

          setupListKeyHandlers(listEl);
          content.appendChild(listEl);
        } else if (type === 'divider') {
          content.contentEditable = 'false';
          content.className = 'block-content block-divider';
          content.innerHTML = '<hr>';
        } else if (type === 'spacer') {
          content.contentEditable = 'false';
          content.className = 'block-content block-spacer';

          const spacerPreview = document.createElement('div');
          spacerPreview.className = 'spacer-preview';
          spacerPreview.style.height = block.dataset.height || '1rem';

          const spacerControls = document.createElement('div');
          spacerControls.className = 'spacer-controls';

          const spacerLabel = document.createElement('label');
          spacerLabel.setAttribute('data-i18n', 'editor.spacerHeight');
          spacerLabel.textContent = 'Height';

          const spacerInput = document.createElement('input');
          spacerInput.type = 'text';
          spacerInput.className = 'spacer-height-input';
          spacerInput.placeholder = '1rem';
          spacerInput.value = block.dataset.height || '1rem';

          spacerInput.addEventListener('input', () => {
            const value = spacerInput.value.trim() || '1rem';
            block.dataset.height = value;
            spacerPreview.style.height = value;
            updateCostRail();
            debouncedPreview();
          });

          spacerLabel.appendChild(spacerInput);
          spacerControls.appendChild(spacerLabel);
          spacerPreview.appendChild(spacerControls);
          content.appendChild(spacerPreview);
        } else if (type === 'codeblock') {
          content.contentEditable = 'true';
          content.className = 'block-content block-codeblock';
          content.dataset.placeholder = 'Code...';
          content.textContent = initialHtml || '';
        } else if (type === 'blockquote') {
          content.contentEditable = 'true';
          content.dataset.placeholder = 'Quote...';
          content.innerHTML = initialHtml;
        } else {
          content.contentEditable = 'true';
          content.dataset.placeholder = type === 'heading' ? 'Heading...' : 'Enter text...';
          content.innerHTML = initialHtml;
        }
        block.appendChild(content);

        updateBlockStyling(block);
        return block;
      }

      function updateBlockStyling(block) {
        const content = block.querySelector('.block-content');
        const type = block.dataset.type;
        const level = block.dataset.level;

        // Reset styles
        content.style.fontSize = '';
        content.style.fontWeight = '';
        content.style.fontStyle = '';
        content.style.borderLeft = '';
        content.style.paddingLeft = '';

        if (type === 'heading') {
          content.style.fontWeight = 'bold';
          const sizes = { 1: '2rem', 2: '1.5rem', 3: '1.25rem', 4: '1.1rem', 5: '1rem', 6: '0.875rem' };
          content.style.fontSize = sizes[level] || '1rem';
          content.dataset.placeholder = 'Heading...';
        } else if (type === 'blockquote') {
          content.style.fontStyle = 'italic';
          content.style.borderLeft = '3px solid var(--border)';
          content.style.paddingLeft = '12px';
          content.dataset.placeholder = 'Quote...';
        } else if (type === 'codeblock') {
          content.dataset.placeholder = 'Code...';
        } else if (type !== 'bloglist' && type !== 'divider' && type !== 'list' && type !== 'spacer') {
          content.dataset.placeholder = 'Enter text...';
        }
      }

      function moveBlock(block, direction) {
        const parent = block?.parentElement;
        if (!parent) return;

        const blocks = Array.from(parent.children).filter(el => el.classList?.contains('block-item'));
        const index = blocks.indexOf(block);
        const newIndex = index + direction;
        if (newIndex < 0 || newIndex >= blocks.length) return;

        if (direction < 0) {
          parent.insertBefore(block, blocks[newIndex]);
        } else {
          parent.insertBefore(block, blocks[newIndex].nextSibling);
        }

        updateCostRail();
        debouncedPreview();
      }

      function insertBlockDirectlyBelow(referenceBlock, newBlock) {
        const parent = referenceBlock?.parentElement;
        if (!parent || !newBlock) return;

        const blockSiblings = Array.from(parent.children).filter(el => el.classList?.contains('block-item'));
        const index = blockSiblings.indexOf(referenceBlock);

        if (index === -1) {
          parent.appendChild(newBlock);
          return;
        }

        const nextBlock = blockSiblings[index + 1] || null;
        if (nextBlock) {
          parent.insertBefore(newBlock, nextBlock);
        } else {
          parent.appendChild(newBlock);
        }
      }

      // ============ FORMAT BUTTONS ============

      function handleFormatClick(cmd, block) {
        // Save selection BEFORE anything else (clicking button may lose it)
        const sel = window.getSelection();
        const hasSelection = sel.rangeCount > 0 && !sel.isCollapsed;
        const currentRange = hasSelection ? sel.getRangeAt(0).cloneRange() : null;

        // For link command, we need a selection
        if (cmd === 'link') {
          if (!hasSelection) {
            alert('Bitte erst Text markieren');
            return;
          }
          savedSelection = currentRange;
          showLinkPopup();
          return;
        }

        // Focus the block content if not already focused
        const content = block.querySelector('.block-content');
        const listItem = block.querySelector('li[contenteditable="true"]');
        const editableEl = listItem || content;

        // Restore selection if we have one
        if (currentRange) {
          sel.removeAllRanges();
          sel.addRange(currentRange);
        } else if (!editableEl.contains(document.activeElement) && editableEl !== document.activeElement) {
          editableEl.focus();
        }

        if (cmd === 'bold') {
          document.execCommand('bold', false, null);
        } else if (cmd === 'italic') {
          document.execCommand('italic', false, null);
        } else if (cmd === 'underline') {
          document.execCommand('underline', false, null);
        } else if (cmd === 'strikethrough') {
          document.execCommand('strikeThrough', false, null);
        } else if (cmd === 'code') {
          wrapSelectionWithTag('code');
        }
        debouncedPreview();
      }

      // ============ FLOATING FORMAT TOOLBAR (disabled - using inline buttons) ============
      /*
      document.addEventListener('selectionchange', () => {
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) {
          formatToolbar.classList.add('hidden');
          return;
        }

        // Check if selection is within block editor
        const range = sel.getRangeAt(0);
        const container = range.commonAncestorContainer;
        const blockContent = container.nodeType === Node.TEXT_NODE
          ? container.parentElement.closest('.block-content')
          : container.closest('.block-content');

        if (!blockContent || !blockEditor.contains(blockContent)) {
          formatToolbar.classList.add('hidden');
          return;
        }

        // Position toolbar above selection
        const rect = range.getBoundingClientRect();
        formatToolbar.style.top = (rect.top + window.scrollY - 40) + 'px';
        formatToolbar.style.left = (rect.left + window.scrollX + rect.width / 2 - 50) + 'px';
        formatToolbar.classList.remove('hidden');
      });

      formatToolbar.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const cmd = btn.dataset.cmd;
        if (cmd === 'bold') {
          document.execCommand('bold', false, null);
        } else if (cmd === 'italic') {
          document.execCommand('italic', false, null);
        } else if (cmd === 'underline') {
          document.execCommand('underline', false, null);
        } else if (cmd === 'strikethrough') {
          document.execCommand('strikeThrough', false, null);
        } else if (cmd === 'code') {
          wrapSelectionWithTag('code');
        } else if (cmd === 'link') {
          showLinkPopup();
        }
      });
      */

      function wrapSelectionWithTag(tagName) {
        const sel = window.getSelection();
        if (!sel.rangeCount || sel.isCollapsed) return;

        const range = sel.getRangeAt(0);
        const selectedText = range.toString();

        // Check if already wrapped in this tag
        const parentTag = sel.anchorNode.parentElement.closest(tagName);
        if (parentTag) {
          // Unwrap: replace tag with its contents
          const parent = parentTag.parentNode;
          while (parentTag.firstChild) {
            parent.insertBefore(parentTag.firstChild, parentTag);
          }
          parent.removeChild(parentTag);
        } else {
          // Wrap selection
          const wrapper = document.createElement(tagName);
          range.surroundContents(wrapper);
        }

        debouncedPreview();
      }

      // ============ LINK POPUP ============

      function showLinkPopup() {
        // savedSelection should already be set by handleFormatClick
        if (!savedSelection) return;

        // Check if selection is inside a link
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(savedSelection);
        const parentLink = sel.anchorNode?.parentElement?.closest('a');
        const existingHref = parentLink ? parentLink.getAttribute('href') : '';
        linkHrefInput.value = existingHref;

        // Reset prefix buttons and set active based on existing href
        linkPopup.querySelectorAll('.link-prefix-btn').forEach(btn => {
          const prefix = btn.dataset.prefix;
          if (existingHref.startsWith(prefix)) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });

        // Update placeholder based on existing prefix
        if (existingHref.startsWith('https://') || existingHref.startsWith('http://')) {
          linkHrefInput.placeholder = 'www.example.com';
        } else if (existingHref.startsWith('mailto:')) {
          linkHrefInput.placeholder = 'name@example.com';
        } else if (existingHref.startsWith('tel:')) {
          linkHrefInput.placeholder = '+49 123 456789';
        } else {
          linkHrefInput.placeholder = '/path or #anchor';
        }

        const rect = savedSelection.getBoundingClientRect();
        linkPopup.style.top = (rect.bottom + window.scrollY + 5) + 'px';
        linkPopup.style.left = (rect.left + window.scrollX) + 'px';
        linkPopup.classList.remove('hidden');
        linkHrefInput.focus();
      }

      linkApplyBtn.addEventListener('click', () => {
        const href = linkHrefInput.value.trim();
        if (!href) {
          linkPopup.classList.add('hidden');
          return;
        }

        // Validate href pattern (same as compiler validation)
        const hrefPattern = /^(\/[a-z0-9._/-]*|#[a-z0-9-]*|[a-z0-9-]+\.html|https?:\/\/[^\s]+|mailto:[^\s]+|tel:[^\s]+)$/i;
        if (!hrefPattern.test(href)) {
          // Give specific hint based on what user likely meant
          let hint;
          if (/^www\./i.test(href) || /\.(com|de|org|net|io|dev|at|ch)$/i.test(href)) {
            hint = `URLs mÃ¼ssen mit https:// beginnen: https://${href}`;
          } else if (/@/.test(href) && !href.startsWith('mailto:')) {
            hint = `E-Mail-Links mÃ¼ssen mit mailto: beginnen: mailto:${href}`;
          } else if (/^[\d\s+()-]+$/.test(href)) {
            hint = `Telefon-Links mÃ¼ssen mit tel: beginnen: tel:${href.replace(/\s/g, '')}`;
          } else {
            hint = 'UngÃ¼ltiges Link-Format';
          }
          Modal.info(hint);
          return;
        }

        if (savedSelection) {
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(savedSelection);
          document.execCommand('createLink', false, href);
        }
        linkPopup.classList.add('hidden');
        savedSelection = null;
        debouncedPreview();
      });

      linkCancelBtn.addEventListener('click', () => {
        linkPopup.classList.add('hidden');
        savedSelection = null;
      });

      // Link prefix buttons
      const linkPrefixBtns = linkPopup.querySelectorAll('.link-prefix-btn');
      const prefixPlaceholders = {
        'https://': 'www.example.com',
        'mailto:': 'name@example.com',
        'tel:': '+49 123 456789'
      };

      linkPrefixBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const prefix = btn.dataset.prefix;
          const currentValue = linkHrefInput.value;

          // Remove any existing prefix
          let cleanValue = currentValue
            .replace(/^https?:\/\//, '')
            .replace(/^mailto:/, '')
            .replace(/^tel:/, '');

          // Toggle: if same prefix was active, just clear it
          if (currentValue.startsWith(prefix)) {
            linkHrefInput.value = cleanValue;
            linkHrefInput.placeholder = '/path or #anchor';
            linkPrefixBtns.forEach(b => b.classList.remove('active'));
          } else {
            linkHrefInput.value = prefix + cleanValue;
            linkHrefInput.placeholder = prefixPlaceholders[prefix];
            linkPrefixBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
          }

          linkHrefInput.focus();
        });
      });

      // ============ ADD BLOCK ============

      addBlockBtn.addEventListener('click', () => {
        addBlockDropdown.classList.toggle('hidden');
      });

      addBlockDropdown.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn) return;

        const type = btn.dataset.type;
        const level = btn.dataset.level;
        const listType = btn.dataset.listType;
        const spacerHeight = btn.dataset.spacerHeight;
        const block = createBlockElement(type, level, '', listType, spacerHeight);
        blockEditor.appendChild(block);
        // Focus on first editable element
        const focusTarget = block.querySelector('li[contenteditable="true"]') || block.querySelector('.block-content');
        if (focusTarget) focusTarget.focus();
        addBlockDropdown.classList.add('hidden');
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.block-actions-row')) {
          addBlockDropdown.classList.add('hidden');
        }
        if (!e.target.closest('.nav-link-popup') && !e.target.closest('#add-nav-link') && !e.target.closest('.nav-chip')) {
          navLinkPopup.classList.add('hidden');
        }
      });

      // ============ BUILD INPUT ============

      function parseInlineNodes(element) {
        const nodes = [];

        function processNodeInto(node, targetArray) {
          if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent;
            if (text) {
              targetArray.push({ type: 'text', text });
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            const children = [];
            for (const child of node.childNodes) {
              processNodeInto(child, children);
            }

            if (tag === 'br') {
              targetArray.push({ type: 'linebreak' });
            } else if (tag === 'b' || tag === 'strong') {
              targetArray.push({ type: 'bold', children });
            } else if (tag === 'i' || tag === 'em') {
              targetArray.push({ type: 'italic', children });
            } else if (tag === 'u') {
              targetArray.push({ type: 'underline', children });
            } else if (tag === 's' || tag === 'strike') {
              targetArray.push({ type: 'strikethrough', children });
            } else if (tag === 'code') {
              targetArray.push({ type: 'code', children });
            } else if (tag === 'a') {
              const href = node.getAttribute('href') || '';
              // Only include link if href is valid (same pattern as compiler)
              const hrefPattern = /^(\/[a-z0-9._/-]*|#[a-z0-9-]*|[a-z0-9-]+\.html|https?:\/\/[^\s]+|mailto:[^\s]+|tel:[^\s]+)$/i;
              if (href && hrefPattern.test(href)) {
                targetArray.push({ type: 'link', href, children });
              } else {
                // Invalid or empty href - just include children without link
                targetArray.push(...children);
              }
            } else {
              targetArray.push(...children);
            }
          }
        }

        for (const child of element.childNodes) {
          processNodeInto(child, nodes);
        }

        if (nodes.length === 0) {
          nodes.push({ type: 'text', text: '' });
        }

        return nodes;
      }

      function serializeBlock(block) {
        const type = block.dataset.type;
        const selector = block.dataset.selector ? block.dataset.selector.trim() : '';

        function withSelector(blockData) {
          if (selector) {
            blockData.selector = selector;
          }
          return blockData;
        }

        if (type === 'section') {
          const sectionBlocks = block.querySelector('.section-blocks');
          const children = [];
          for (const childBlock of sectionBlocks.querySelectorAll(':scope > .block-item')) {
            children.push(serializeBlock(childBlock));
          }
          return withSelector({
            type: 'section',
            background: block.dataset.background,
            color: block.dataset.color,
            pattern: block.dataset.pattern || null,
            patternColor: block.dataset.patternColor || null,
            patternOpacity: block.dataset.patternOpacity || null,
            width: block.dataset.width || null,
            padding: block.dataset.padding || null,
            align: block.dataset.align || null,
            children
          });
        }

        if (type === 'layout') {
          const cellsGrid = block.querySelector('.layout-cells-grid');
          const cells = [];
          for (const cell of cellsGrid.querySelectorAll('.layout-cell')) {
            const cellBlocks = cell.querySelector('.layout-cell-blocks');
            const children = [];
            for (const childBlock of cellBlocks.querySelectorAll(':scope > .block-item')) {
              children.push(serializeBlock(childBlock));
            }
            cells.push({
              children,
              textAlign: cell.dataset.textAlign || null,
              padding: cell.dataset.padding || null,
              margin: cell.dataset.margin || null
            });
          }
          return withSelector({
            type: 'layout',
            columns: parseInt(block.dataset.columns || '2'),
            cells
          });
        }

        if (type === 'bloglist') {
          return withSelector({ type: 'bloglist' });
        }
        if (type === 'divider') {
          return withSelector({ type: 'divider' });
        }
        if (type === 'spacer') {
          return withSelector({
            type: 'spacer',
            height: block.dataset.height || '1rem'
          });
        }
        if (type === 'codeblock') {
          const contentEl = block.querySelector('.block-content');
          return withSelector({
            type: 'codeblock',
            content: contentEl.textContent || ''
          });
        }
        if (type === 'list' || type === 'unordered-list' || type === 'ordered-list') {
          const listEl = block.querySelector('.editable-list');
          const items = [];
          for (const li of listEl.querySelectorAll('li')) {
            items.push({
              children: parseInlineNodes(li)
            });
          }
          const listType = block.dataset.listType || (type === 'ordered-list' ? 'ordered' : 'unordered');
          return withSelector({
            type: listType === 'ordered' ? 'ordered-list' : 'unordered-list',
            items
          });
        }

        const contentEl = block.querySelector('.block-content');
        const children = parseInlineNodes(contentEl);

        if (type === 'heading') {
          return withSelector({
            type: 'heading',
            level: parseInt(block.dataset.level, 10),
            children
          });
        }
        if (type === 'blockquote') {
          return withSelector({ type: 'blockquote', children });
        }
        return withSelector({ type: 'paragraph', children });
      }

      function getContentFromBlocks() {
        const blocks = blockEditor.querySelectorAll(':scope > .block-item');
        const content = [];
        for (const block of blocks) {
          content.push(serializeBlock(block));
        }
        return content;
      }

      function getNavigationItems() {
        const chips = navLinks.querySelectorAll('.nav-chip');
        return Array.from(chips).map(chip => ({
          text: chip.textContent,
          href: chip.dataset.href
        }));
      }


      async function buildInput(allowPagination = false) {
        const content = getContentFromBlocks();

        // For preview with empty content, use minimal placeholder
        const finalContent = content.length > 0
          ? content
          : [{ type: 'paragraph', children: [{ type: 'text', text: '' }] }];

        // Load posts if bloglist block is present
        let posts = [];
        const hasBloglist = finalContent.some(block => block.type === 'bloglist');
        if (hasBloglist) {
          try {
            posts = await App.getPosts();
          } catch (err) {
            console.warn('Failed to load posts for bloglist:', err);
          }
        }

        let navigation = null;
        if (navEnabled.checked) {
          const items = getNavigationItems();
          if (items.length > 0) {
            navigation = { items };
          }
        }

        let footer = null;
        if (footerEnabled.checked && footerText.value.trim()) {
          footer = { content: footerText.value.trim() };
        }

        let css = null;
        if (cssEnabled.checked && cssRules.value.trim()) {
          css = { rules: cssRules.value.trim() };
        }

        let meta = null;
        if (metaEnabled.checked) {
          const description = metaDescription.value.trim();
          const author = metaAuthor.value.trim();
          if (description || author) {
            meta = {};
            if (description) meta.description = description;
            if (author) meta.author = author;
          }
        }

        // Title override
        let titleOverride = null;
        if (titleOverrideEnabled.checked && titleOverrideInput.value.trim()) {
          titleOverride = titleOverrideInput.value.trim();
        }

        return {
          slug: slugInput.value.trim() || 'untitled',
          title: titleInput.value.trim() || 'Untitled',
          siteTitle: (window.globalConfig?.siteTitleEnabled !== false) ? (window.globalConfig?.siteTitle || null) : null,
          titleOverride,
          content: finalContent,
          navigation,
          footer,
          css,
          meta,
          icons: [],
          posts,
          allowPagination,
          buildId: crypto.randomUUID(),
          pageType: pageTypeSelect.value,
        };
      }

      // ============ BYTE COUNTER & COST RAIL ============

      function formatBytes(bytes) {
        return bytes.toLocaleString('de-DE') + ' B';
      }

      function updateByteCounter(totalBytes, overheadBytes = 0, contentBytes = null, breakdown = null) {
        const limit = 14336;
        const actualContentBytes = contentBytes !== null ? contentBytes : Math.max(0, totalBytes - overheadBytes);
        const overheadPercent = Math.min((overheadBytes / limit) * 100, 100);
        const totalPercent = Math.min((totalBytes / limit) * 100, 100);

        // Update Build Summary breakdown
        if (breakdown) {
          breakdownBase.textContent = formatBytes(breakdown.base);
          breakdownTitle.textContent = formatBytes(breakdown.title || 0);
          breakdownFavicon.textContent = formatBytes(breakdown.favicon || 0);
          breakdownNav.textContent = formatBytes(breakdown.navigation);
          breakdownMeta.textContent = formatBytes(breakdown.meta || 0);
          breakdownFooter.textContent = formatBytes(breakdown.footer);
          breakdownCss.textContent = formatBytes(breakdown.css);
          breakdownContent.textContent = formatBytes(breakdown.content);
          breakdownTotal.textContent = `${formatBytes(totalBytes)} / 14.336 B`;

          // Update rail indicators
          navBytesEl.textContent = formatBytes(breakdown.navigation);
          metaBytesEl.textContent = formatBytes(breakdown.meta || 0);
          footerBytesEl.textContent = formatBytes(breakdown.footer);
          cssBytesEl.textContent = formatBytes(breakdown.css);
        }

        // Update Cost Rail content total
        costContentTotal.textContent = formatBytes(actualContentBytes);

        // Calculate angles for pie chart (360 degrees = 100%)
        const overheadDeg = (overheadPercent / 100) * 360;
        const totalDeg = (totalPercent / 100) * 360;

        // Determine content color based on usage
        let contentColor = 'var(--accent)';
        pieContentDot.classList.remove('warning', 'danger');
        if (totalPercent >= 100) {
          contentColor = '#dc2626';
          pieContentDot.classList.add('danger');
        } else if (totalPercent >= 80) {
          contentColor = '#f59e0b';
          pieContentDot.classList.add('warning');
        }

        // Update pie chart with conic-gradient
        pieChart.style.background = `conic-gradient(
          var(--gray-400) 0deg ${overheadDeg}deg,
          ${contentColor} ${overheadDeg}deg ${totalDeg}deg,
          var(--gray-200) ${totalDeg}deg 360deg
        )`;

        // Update percentage in center
        piePercent.textContent = `${Math.round(totalPercent)}%`;
      }

      function updateCostRail() {
        let totalContentBytes = 0;
        const encoder = new TextEncoder();

        function parseSelector(selector) {
          if (!selector || typeof selector !== 'string') {
            return { id: '', classes: [] };
          }

          const safeToken = token => {
            if (!token) return '';
            const cleaned = token.trim().replace(/[^a-zA-Z0-9_-]/g, '');
            return cleaned;
          };

          const normalized = selector.trim();
          if (!normalized) return { id: '', classes: [] };

          if (normalized.startsWith('#')) {
            const [idToken, ...classTokens] = normalized.slice(1).split('.');
            const id = safeToken(idToken);
            const classes = classTokens.map(safeToken).filter(Boolean);
            return { id, classes };
          }

          const source = normalized.startsWith('.') ? normalized.slice(1) : normalized;
          const classes = source
            .split(/[.\s]+/)
            .map(safeToken)
            .filter(Boolean);
          return { id: '', classes };
        }

        function selectorAttr(selector, baseClasses = []) {
          const parsed = parseSelector(selector);
          const classList = [...baseClasses, ...parsed.classes].filter(Boolean);
          const idAttr = parsed.id ? ` id="${parsed.id}"` : '';
          const classAttr = classList.length > 0 ? ` class="${classList.join(' ')}"` : '';
          return `${idAttr}${classAttr}`;
        }

        function renderBlockHtmlForBytes(blockData) {
          if (!blockData || typeof blockData !== 'object') return '';

          if (blockData.type === 'bloglist') {
            const attrs = selectorAttr(blockData.selector);
            return `<div${attrs}><!-- bloglist --></div>`;
          }
          if (blockData.type === 'divider') {
            const attrs = selectorAttr(blockData.selector);
            return `<hr${attrs}>`;
          }
          if (blockData.type === 'spacer') {
            const attrs = selectorAttr(blockData.selector);
            return `<div${attrs} style="height:${blockData.height || '1rem'}"></div>`;
          }
          if (blockData.type === 'codeblock') {
            const attrs = selectorAttr(blockData.selector);
            return `<pre${attrs}><code>${escapeHtml(blockData.content || '')}</code></pre>`;
          }
          if (blockData.type === 'unordered-list' || blockData.type === 'ordered-list') {
            const tag = blockData.type === 'unordered-list' ? 'ul' : 'ol';
            const items = (blockData.items || []).map(item => {
              const inlineHtml = inlineNodesToHtml(item.children || []);
              return `<li>${inlineHtml}</li>`;
            }).join('\n');
            const attrs = selectorAttr(blockData.selector);
            return `<${tag}${attrs}>\n${items}\n</${tag}>`;
          }
          if (blockData.type === 'layout') {
            const cellsHtml = (blockData.cells || []).map(cell => {
              const cellContent = (cell.children || []).map(child => renderBlockHtmlForBytes(child)).join('\n');
              const cellStyles = [];
              if (cell.textAlign && cell.textAlign !== 'left') cellStyles.push(`text-align:${cell.textAlign}`);
              if (cell.padding && cell.padding !== '10px') cellStyles.push(`padding:${cell.padding}`);
              if (cell.margin && cell.margin !== '10px') cellStyles.push(`margin:${cell.margin}`);
              const cellStyle = cellStyles.length ? ` style="${cellStyles.join(';')}"` : '';
              return `<div class="cell"${cellStyle}>${cellContent}</div>`;
            }).join('\n');

            const styles = [];
            styles.push('display:inline-grid');
            styles.push('width:fit-content');
            styles.push('max-width:100%');
            if (blockData.columns !== 1) {
              styles.push(`grid-template-columns:repeat(${blockData.columns},1fr)`);
            }
            if (blockData.rows) {
              styles.push(`grid-template-rows:repeat(${blockData.rows},auto)`);
            }
            const rowGap = blockData.rowGap || '0';
            const colGap = blockData.columnGap || '0';
            if (!(rowGap === '0' && colGap === '0')) {
              if (rowGap === colGap) {
                styles.push(`gap:${rowGap}`);
              } else {
                styles.push(`gap:${rowGap} ${colGap}`);
              }
            }

            const classes = ['layout'];
            if (blockData.className) classes.push(blockData.className);
            const attrs = selectorAttr(blockData.selector, classes);
            return `<div${attrs} style="${styles.join(';')}">${cellsHtml}</div>`;
          }
          if (blockData.type === 'section') {
            const childrenHtml = (blockData.children || []).map(child => renderBlockHtmlForBytes(child)).join('\n');
            const styles = [];
            if (blockData.background && blockData.background !== 'transparent') styles.push(`--sb:${blockData.background}`);
            if (blockData.color && blockData.color !== 'inherit') styles.push(`--sc:${blockData.color}`);
            if (blockData.pattern && blockData.patternColor && blockData.patternOpacity && blockData.patternOpacity !== '0' && blockData.patternOpacity !== 0) {
              const hex = blockData.patternColor;
              const opacity = blockData.patternOpacity;
              const r = parseInt(hex.substring(1, 3), 16);
              const g = parseInt(hex.substring(3, 5), 16);
              const b = parseInt(hex.substring(5, 7), 16);
              styles.push(`--pc:rgba(${r},${g},${b},${opacity})`);
            }
            if (blockData.width && blockData.width !== '100%') styles.push(`--sw:${blockData.width}`);
            if (blockData.padding && blockData.padding !== '3rem') styles.push(`--sp:${blockData.padding}`);
            if (blockData.align && blockData.align !== 'start') styles.push(`--sa:${blockData.align}`);

            const classes = ['section'];
            if (blockData.pattern === 'dots') classes.push('bg-pattern-dots');
            if (blockData.pattern === 'grid') classes.push('bg-pattern-grid');
            if (blockData.pattern === 'stripes') classes.push('bg-pattern-stripes');
            if (blockData.pattern === 'cross') classes.push('bg-pattern-cross');
            if (blockData.pattern === 'hexagons') classes.push('bg-pattern-hexagons');

            const styleAttr = styles.length > 0 ? ` style="${styles.join(';')}"` : '';
            const attrs = selectorAttr(blockData.selector, classes);
            return `<div${attrs}${styleAttr}>${childrenHtml}</div>`;
          }

          const inlineHtml = inlineNodesToHtml(blockData.children || []);
          const attrs = selectorAttr(blockData.selector);
          if (blockData.type === 'heading') {
            const level = blockData.level ?? 1;
            return `<h${level}${attrs}>${inlineHtml}</h${level}>`;
          }
          if (blockData.type === 'blockquote') {
            return `<blockquote${attrs}>${inlineHtml}</blockquote>`;
          }
          return `<p${attrs}>${inlineHtml}</p>`;
        }

        function estimateBlockBytes(block) {
          const blockData = serializeBlock(block);
          const html = renderBlockHtmlForBytes(blockData);
          return encoder.encode(html).length;
        }

        // Recursive helper to calculate bytes for a block and its children
        function processBlock(block) {
            const type = block.dataset.type;
            let bytes = 0;
            let label = 'Block';

            if (type === 'section') {
                label = 'Section';
                bytes = estimateBlockBytes(block);

                const childrenWrapper = block.querySelector('.section-blocks');
                if (childrenWrapper) {
                  const children = childrenWrapper.querySelectorAll(':scope > .block-item');
                  children.forEach(child => {
                    processBlock(child);
                  });
                }
            } else if (type === 'layout') {
                label = 'Layout';
                bytes = estimateBlockBytes(block);

                const cellsGrid = block.querySelector('.layout-cells-grid');
                if (cellsGrid) {
                  const cellBlocks = cellsGrid.querySelectorAll('.layout-cell .layout-cell-blocks > .block-item');
                  cellBlocks.forEach(child => {
                    processBlock(child);
                  });
                }
            } else {
                bytes = estimateBlockBytes(block);

                // Labels
                const level = block.dataset.level;
                const listType = block.dataset.listType;
                if (type === 'heading') label = `H${level}`;
                else if (type === 'paragraph') label = 'Paragraph';
                else if (type === 'bloglist') label = 'Bloglist';
                else if (type === 'list' || type === 'unordered-list') {
                   if (listType === 'ordered' || type === 'ordered-list') label = 'OL';
                   else label = 'UL';
                }
                else if (type === 'blockquote') label = 'Quote';
                else if (type === 'codeblock') label = 'Code';
                else if (type === 'divider') label = 'HR';
                else if (type === 'spacer') label = 'Spacer';
            }

            // Update this block's indicator
            let byteIndicator = block.querySelector(':scope > .block-byte-indicator');
            if (byteIndicator) {
                byteIndicator.innerHTML = `<span>${label}</span><span>${formatBytes(bytes)}</span>`;
            }

            return bytes;
        }

        // Only iterate TOP-LEVEL blocks in the editor
        const topLevelBlocks = blockEditor.querySelectorAll(':scope > .block-item');
        topLevelBlocks.forEach(block => {
             totalContentBytes += processBlock(block);
        });

        // Newlines between top-level blocks
        if (topLevelBlocks.length > 1) {
            totalContentBytes += topLevelBlocks.length - 1;
        }

        // Update content total
        costContentTotal.textContent = formatBytes(totalContentBytes);
      }

      function updateTitleBytes() {
        const pageTitle = titleInput.value.trim() || 'Untitled';
        const titleOverrideValue = titleOverrideInput.value.trim();
        const siteTitleEnabled = window.globalConfig?.siteTitleEnabled !== false;
        const siteTitleText = window.globalConfig?.siteTitle;

        // Page Title: just the title input value
        const pageTitleBytes = new TextEncoder().encode(pageTitle).length;
        titleBytesEl.textContent = formatBytes(pageTitleBytes);

        // Browser Title: final <title> tag content
        let browserTitle;
        if (titleOverrideEnabled.checked && titleOverrideValue) {
          browserTitle = titleOverrideValue;
        } else if (siteTitleEnabled && siteTitleText) {
          browserTitle = `${pageTitle} | ${siteTitleText}`;
        } else {
          browserTitle = pageTitle;
        }

        // <title>TITEL</title> = 15 bytes markup + title bytes
        const browserTitleBytes = new TextEncoder().encode(browserTitle).length + 15;
        browserTitleBytesEl.textContent = formatBytes(browserTitleBytes);
      }

      // ============ MODAL SYSTEM ============

      const Modal = (() => {
        const backdrop = document.getElementById('modal-backdrop');
        const modal = document.getElementById('modal');
        const message = document.getElementById('modal-message');
        const actions = document.getElementById('modal-actions');

        function hide() {
          modal.classList.add('hidden');
          backdrop.classList.add('hidden');
          modal.className = 'modal hidden';
          actions.innerHTML = '';
        }

        function show(text, buttons, type = '', html = false) {
          if (html) {
            message.innerHTML = text;
          } else {
            message.textContent = text;
          }
          actions.innerHTML = '';
          modal.className = 'modal' + (type ? ` modal-${type}` : '');

          buttons.forEach(btn => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = btn.text;
            button.className = btn.class || '';
            button.addEventListener('click', () => {
              hide();
              if (btn.action) btn.action();
            });
            actions.appendChild(button);
          });

          backdrop.classList.remove('hidden');
          modal.classList.remove('hidden');
        }

        return {
          confirm(text) {
            return new Promise(resolve => {
              show(text, [
                { text: 'Yes', class: 'btn-primary', action: () => resolve(true) },
                { text: 'Cancel', class: 'btn-secondary', action: () => resolve(false) }
              ]);
            });
          },

          success(text, buttons = null, html = false) {
            show(text, buttons || [{ text: 'OK', class: 'btn-primary' }], 'success', html);
          },

          error(text, html = false) {
            show(text, [{ text: 'OK', class: 'btn-primary' }], 'error', html);
          },

          info(text) {
            show(text, [{ text: 'OK', class: 'btn-primary' }]);
          },

          hide
        };
      })();

      // Export Modal for inline handlers
      window.Modal = Modal;

      // ============ PUBLISH ============

      publishBtn.addEventListener('click', async () => {
        // Validate title before publish
        if (!titleInput.value.trim()) {
          Modal.error(t('editor.buildError', { error: t('editor.titleRequired') }));
          return;
        }

        // Validate content before publish
        const blocks = blockEditor.querySelectorAll('.block-item');
        if (blocks.length === 0) {
          Modal.error(t('editor.buildError', { error: t('editor.blockRequired') }));
          return;
        }

        const confirmed = await Modal.confirm(t('editor.buildConfirm'));
        if (!confirmed) return;

        publishBtn.disabled = true;

        try {
          // First, check if pagination would be needed
          // Use App.preview() to include global settings (navigation, footer, CSS, etc.)
          const inputPreview = await buildInput(false);

          let shouldPaginate = false;

          // Try compiling without pagination first (with global settings applied)
          const previewResult = await App.preview(inputPreview);

          // Check if size limit exceeded (App.preview returns exceeded: true instead of throwing)
          if (previewResult.exceeded) {
            // Post is too large, try with pagination
            const inputWithPagination = await buildInput(true);
            const paginatedResult = await App.preview(inputWithPagination);

            if (!paginatedResult.exceeded && paginatedResult.measurements && paginatedResult.measurements.length > 1) {
              const estimatedPageCount = paginatedResult.measurements.length;

              // Ask user if they want to split
              const splitConfirmed = await Modal.confirm(
                t('editor.splitConfirm', { bytes: previewResult.bytes, pages: estimatedPageCount })
              );

              if (splitConfirmed) {
                shouldPaginate = true;
              } else {
                // User declined, abort publish
                Modal.error(t('editor.tooLarge'));
                publishBtn.disabled = false;
                return;
              }
            } else {
              // Can't be paginated
              Modal.error(t('editor.cannotSplit'));
              publishBtn.disabled = false;
              return;
            }
          } else if (previewResult.bytes > 14336) {
            // Compiled successfully but over 14KB - offer to split
            const inputWithPagination = await buildInput(true);
            const paginatedResult = await App.preview(inputWithPagination);

            if (!paginatedResult.exceeded && paginatedResult.measurements && paginatedResult.measurements.length > 1) {
              const estimatedPageCount = paginatedResult.measurements.length;

              // Ask user if they want to split
              const splitConfirmed = await Modal.confirm(
                t('editor.splitConfirm', { bytes: previewResult.bytes, pages: estimatedPageCount })
              );

              if (splitConfirmed) {
                shouldPaginate = true;
              } else {
                // User declined, abort publish
                publishBtn.disabled = false;
                return;
              }
            }
          }

          // Now do the actual publish with the user's choice
          const input = await buildInput(shouldPaginate);
          const result = await App.publish(input);

          const sizeInfo = result.pageCount && result.pageCount > 1
            ? `${result.pageCount} pages, ${result.totalBytes} bytes`
            : `${result.bytes} bytes`;

          Modal.success(
            `<strong>${t('editor.buildSuccess')}</strong><br>/${result.slug} (${sizeInfo})`,
            [
              { text: t('modal.ok'), class: 'btn-secondary' },
              { text: t('dashboard.view'), class: 'btn-primary', action: () => window.open(`/${result.slug}`, '_blank') }
            ],
            true
          );

          // Only clear fields if NOT in edit mode
          // In edit mode, preserve the form so user can continue iterating
          if (!isEditMode) {
            // Clear all fields after publish
            titleInput.value = '';
            slugInput.value = '';
            blockEditor.innerHTML = '';

            // Add one empty paragraph block
            const emptyBlock = createBlockElement('paragraph');
            blockEditor.appendChild(emptyBlock);

            // Reset title override
            titleOverrideEnabled.checked = false;
            titleOverrideEnabled.dispatchEvent(new Event('change'));
            titleOverrideInput.value = '';

            // Reset navigation
            navEnabled.checked = false;
            navEnabled.dispatchEvent(new Event('change'));
            loadGlobalNavigation();

            // Reset footer
            footerEnabled.checked = false;
            footerEnabled.dispatchEvent(new Event('change'));
            footerText.value = '';

            // Reset meta
            metaEnabled.checked = false;
            metaEnabled.dispatchEvent(new Event('change'));
            metaDescription.value = '';
            metaAuthor.value = '';

            // Reset CSS
            cssEnabled.checked = false;
            cssEnabled.dispatchEvent(new Event('change'));
            cssRules.value = '';
            liveCSS.textContent = '';

            // Reset page type
            pageTypeSelect.value = 'post';
            pageTypeHint.textContent = '';

            // Clear auto-save
            clearAutoSave();

            // Reset byte counter
            updateByteCounter(0, 0);
            updateCostRail();
            updateTitleBytes();
          }

          // Re-enable publish button
          publishBtn.disabled = false;
          // Set appropriate button text based on mode
          publishBtn.textContent = isEditMode ? t('editor.recompile') : t('editor.buildPublish');
        } catch (err) {
          Modal.error(err.message);
          console.error(err);
          publishBtn.disabled = false;
        }
      });

      // ============ INIT ============

      // Load global values into fields
      loadGlobalNavigation();
      loadGlobalFooter();
      loadGlobalMeta();
      loadGlobalCSS();

      // Set initial disabled states (after loading global values)
      navEditor.classList.remove('hidden');
      addNavLinkBtn.disabled = true;

      // Apply disabled state to navigation chips
      const initialChips = navLinks.querySelectorAll('.nav-chip');
      initialChips.forEach(chip => {
        chip.style.pointerEvents = 'none';
        chip.style.opacity = '0.6';
      });

      footerEditor.classList.remove('hidden');
      footerText.disabled = true;
      insertBytesBtn.disabled = true;

      metaEditor.classList.remove('hidden');
      metaDescription.disabled = true;
      metaAuthor.disabled = true;

      // Title override - disabled by default
      titleOverrideInput.disabled = true;
      updateTitleOverrideHint();

      cssEditor.classList.remove('hidden');
      cssRules.disabled = true;

      function debounce(fn, delay = 300) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      }

      // ============ SEED TEMPLATES ============

      const templateSelector = document.getElementById('template-selector');
      const templateSelectorContainer = document.getElementById('template-selector-container');

      async function loadSeedTemplates() {
        try {
          const seeds = await App.getSeeds();
          
          if (seeds && seeds.length > 0) {
            seeds.forEach(seed => {
              const option = document.createElement('option');
              option.value = seed.name;
              option.textContent = seed.label;
              templateSelector.appendChild(option);
            });
          }
        } catch (err) {
          console.error('Failed to load seed templates:', err);
        }
      }

      templateSelector.addEventListener('change', async function() {
        const seedName = this.value;
        if (!seedName) return;
        
        try {
          const { sourceData } = await App.clonePage(seedName, 'seed');
          loadFromSource(sourceData);
          
          // Update title
          const pageTitle = document.getElementById('page-title');
          const pageSubtitle = document.getElementById('page-subtitle');
          pageTitle.textContent = `New (from ${seedName.replace('-', ' ')})`;
          pageSubtitle.textContent = 'Set title and slug to create a new page';
          
          // Reset dropdown
          this.value = '';
        } catch (err) {
          Modal.error(t('editor.templatesError', { error: err.message }));
          this.value = '';
        }
      });

      // Load seed templates on page load (only in new mode)
      const urlParams = new URLSearchParams(window.location.search);
      const editSlug = urlParams.get('edit');
      const isCloning = urlParams.get('clone') === 'true';
      
      if (!editSlug && !isCloning) {
        loadSeedTemplates();
      } else {
        // Hide template selector in edit/clone mode
        templateSelectorContainer.style.display = 'none';
      }

      // Check for edit mode (recompile from source)


      if (editSlug) {
        // Edit mode: load from source
        try {
          const sourceData = await App.getSourceData(editSlug);
          if (sourceData) {
            isEditMode = true;
            editingSlug = editSlug;
            loadFromSource(sourceData);
            // Show edit mode banner
            showEditModeBanner();
          }
        } catch (err) {
          console.error('Failed to load source:', err);
          Modal.error(t('editor.loadSourceError', { error: err.message }));
        }
      } else if (isCloning) {
        // Clone mode: load from sessionStorage
        try {
          const clonedData = sessionStorage.getItem('clonedSource');
          if (clonedData) {
            const sourceData = JSON.parse(clonedData);
            loadFromSource(sourceData);
            sessionStorage.removeItem('clonedSource');
            // Show notification
            const pageTitle = document.getElementById('page-title');
            const pageSubtitle = document.getElementById('page-subtitle');
            pageTitle.textContent = 'New (Cloned)';
            pageSubtitle.textContent = 'Set title and slug to create a new page';
          }
        } catch (err) {
          console.error('Failed to load cloned source:', err);
        }
      } else {
        // New document mode: try to restore from auto-save
        loadFromLocalStorage();
      }

      // Show edit mode indicator in title
      function showEditModeBanner() {
        const pageTitle = document.getElementById('page-title');
        const pageSubtitle = document.getElementById('page-subtitle');
        pageTitle.innerHTML = `Recompile <span style="font-weight: 400; color: var(--text-secondary);">/ ${editingSlug}</span>`;
        pageSubtitle.textContent = 'Editing source Â· requires rebuild';
        pageSubtitle.style.display = 'block';
        
        // Change button text to "Recompile" in edit mode
        publishBtn.setAttribute('data-i18n', 'editor.recompile');
        publishBtn.textContent = t('editor.recompile');
      }

      // ============ CLEAR ALL BUTTON ============

      document.getElementById('clear-all-btn').addEventListener('click', async () => {
        const confirmed = await Modal.confirm(t('editor.resetConfirm'));
        if (!confirmed) return;

        // Clear all fields
        titleInput.value = '';
        slugInput.value = '';
        blockEditor.innerHTML = '';

        // Add one empty paragraph block
        const emptyBlock = createBlockElement('paragraph');
        blockEditor.appendChild(emptyBlock);

        // Reset title override (disabled)
        titleOverrideEnabled.checked = false;
        titleOverrideEnabled.dispatchEvent(new Event('change'));
        titleOverrideInput.value = '';

        // Reset navigation to global (disabled)
        navEnabled.checked = false;
        navEnabled.dispatchEvent(new Event('change'));
        loadGlobalNavigation();

        // Reset footer to global (disabled)
        footerEnabled.checked = false;
        footerEnabled.dispatchEvent(new Event('change'));
        loadGlobalFooter();

        // Reset meta to global (disabled)
        metaEnabled.checked = false;
        metaEnabled.dispatchEvent(new Event('change'));
        loadGlobalMeta();

        // Reset CSS to global (disabled)
        cssEnabled.checked = false;
        cssEnabled.dispatchEvent(new Event('change'));
        loadGlobalCSS();

        // Reset page type
        pageTypeSelect.value = 'post';
        pageTypeHint.textContent = '';

        // Clear auto-save
        clearAutoSave();

        // Reset byte counter
        updateByteCounter(0, 0);
        updateCostRail();
        updateTitleBytes();
      });

      updateByteCounter(0, 0);
      updateCostRail();
      updateTitleBytes();

      // Auto-update byte counter on content changes
      debouncedPreview = debounce(async () => {
        saveToLocalStorage(); // Safety backup to localStorage (works in both modes)
        try {
          const input = await buildInput();
          const result = await App.preview(input);
          updateByteCounter(result.bytes, result.overheadBytes || 0, result.contentBytes, result.breakdown);

          // Clear previous block warnings
          blockEditor.querySelectorAll('.block-item.block-too-large').forEach(el => {
            el.classList.remove('block-too-large');
          });

          // Check if a block is too large for pagination
          if (result.blockTooLarge) {
            const blocks = blockEditor.querySelectorAll('.block-item');
            const blockIndex = result.blockTooLarge.blockIndex;
            if (blocks[blockIndex]) {
              blocks[blockIndex].classList.add('block-too-large');
            }
          }
        } catch (e) {
          // Ignore preview errors during editing
        }
      }, 500);

      // Listen for content changes
      blockEditor.addEventListener('input', () => {
        debouncedPreview();
        updateCostRail();
      });
      titleInput.addEventListener('input', debouncedPreview);
      titleOverrideInput.addEventListener('input', debouncedPreview);
      titleOverrideEnabled.addEventListener('change', debouncedPreview);
      footerText.addEventListener('input', debouncedPreview);
      cssRules.addEventListener('input', debouncedPreview);
      metaDescription.addEventListener('input', debouncedPreview);
      metaAuthor.addEventListener('input', debouncedPreview);
      navEnabled.addEventListener('change', debouncedPreview);
      footerEnabled.addEventListener('change', debouncedPreview);
      metaEnabled.addEventListener('change', debouncedPreview);
      cssEnabled.addEventListener('change', debouncedPreview);

      // Update cost rail when blocks change
      const observer = new MutationObserver(() => {
        updateCostRail();
      });
      observer.observe(blockEditor, { childList: true });

      // Initial preview to get overhead
      debouncedPreview();

    })();
  </script>
</body>

</html>